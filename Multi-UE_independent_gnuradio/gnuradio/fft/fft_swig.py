# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _fft_swig
else:
    import _fft_swig

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def high_res_timer_now() -> "gr::high_res_timer_type":
    r"""high_res_timer_now() -> gr::high_res_timer_type"""
    return _fft_swig.high_res_timer_now()

def high_res_timer_now_perfmon() -> "gr::high_res_timer_type":
    r"""high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
    return _fft_swig.high_res_timer_now_perfmon()

def high_res_timer_tps() -> "gr::high_res_timer_type":
    r"""high_res_timer_tps() -> gr::high_res_timer_type"""
    return _fft_swig.high_res_timer_tps()

def high_res_timer_epoch() -> "gr::high_res_timer_type":
    r"""high_res_timer_epoch() -> gr::high_res_timer_type"""
    return _fft_swig.high_res_timer_epoch()
class fft_vcc(object):
    r"""
    Compute forward or reverse FFT. complex vector in / complex vector out.

    The FFT operation is defined for a vector  with  uniformly sampled points by





     is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


    The IFFT operation is defined for a vector  with  uniformly sampled points by





     is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


    , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

    Constructor Specific Documentation:



    Args:
        fft_size : N.
        forward : True performs FFT, False performs IFFT.
        window : Window function to be used.
        shift : True moves DC carrier to the middle.
        nthreads : Number of underlying threads.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(fft_size: "int", forward: "bool", window: "pmt_vector_float", shift: "bool"=False, nthreads: "int"=1) -> "gr::fft::fft_vcc::sptr":
        r"""
        make(int fft_size, bool forward, pmt_vector_float window, bool shift=False, int nthreads=1) -> fft_vcc_sptr
        Compute forward or reverse FFT. complex vector in / complex vector out.

        The FFT operation is defined for a vector  with  uniformly sampled points by





         is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


        The IFFT operation is defined for a vector  with  uniformly sampled points by





         is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


        , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

        Constructor Specific Documentation:



        Args:
            fft_size : N.
            forward : True performs FFT, False performs IFFT.
            window : Window function to be used.
            shift : True moves DC carrier to the middle.
            nthreads : Number of underlying threads.
        """
        return _fft_swig.fft_vcc_make(fft_size, forward, window, shift, nthreads)

    def set_nthreads(self, n: "int") -> "void":
        r"""set_nthreads(fft_vcc self, int n)"""
        return _fft_swig.fft_vcc_set_nthreads(self, n)

    def nthreads(self) -> "int":
        r"""nthreads(fft_vcc self) -> int"""
        return _fft_swig.fft_vcc_nthreads(self)

    def set_window(self, window: "pmt_vector_float") -> "bool":
        r"""set_window(fft_vcc self, pmt_vector_float window) -> bool"""
        return _fft_swig.fft_vcc_set_window(self, window)
    __swig_destroy__ = _fft_swig.delete_fft_vcc

# Register fft_vcc in _fft_swig:
_fft_swig.fft_vcc_swigregister(fft_vcc)

def fft_vcc_make(fft_size: "int", forward: "bool", window: "pmt_vector_float", shift: "bool"=False, nthreads: "int"=1) -> "gr::fft::fft_vcc::sptr":
    r"""
    fft_vcc_make(int fft_size, bool forward, pmt_vector_float window, bool shift=False, int nthreads=1) -> fft_vcc_sptr
    Compute forward or reverse FFT. complex vector in / complex vector out.

    The FFT operation is defined for a vector  with  uniformly sampled points by





     is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


    The IFFT operation is defined for a vector  with  uniformly sampled points by





     is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


    , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

    Constructor Specific Documentation:



    Args:
        fft_size : N.
        forward : True performs FFT, False performs IFFT.
        window : Window function to be used.
        shift : True moves DC carrier to the middle.
        nthreads : Number of underlying threads.
    """
    return _fft_swig.fft_vcc_make(fft_size, forward, window, shift, nthreads)

class fft_vfc(object):
    r"""
    Compute forward or reverse FFT. complex vector in / complex vector out.

    The FFT operation is defined for a vector  with  uniformly sampled points by





     is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


    The IFFT operation is defined for a vector  with  uniformly sampled points by





     is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


    , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

    Constructor Specific Documentation:



    Args:
        fft_size : N.
        forward : True performs FFT, False performs IFFT.
        window : Window function to be used.
        nthreads : Number of underlying threads.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(fft_size: "int", forward: "bool", window: "pmt_vector_float", nthreads: "int"=1) -> "gr::fft::fft_vfc::sptr":
        r"""
        make(int fft_size, bool forward, pmt_vector_float window, int nthreads=1) -> fft_vfc_sptr
        Compute forward or reverse FFT. complex vector in / complex vector out.

        The FFT operation is defined for a vector  with  uniformly sampled points by





         is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


        The IFFT operation is defined for a vector  with  uniformly sampled points by





         is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


        , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

        Constructor Specific Documentation:



        Args:
            fft_size : N.
            forward : True performs FFT, False performs IFFT.
            window : Window function to be used.
            nthreads : Number of underlying threads.
        """
        return _fft_swig.fft_vfc_make(fft_size, forward, window, nthreads)

    def set_nthreads(self, n: "int") -> "void":
        r"""set_nthreads(fft_vfc self, int n)"""
        return _fft_swig.fft_vfc_set_nthreads(self, n)

    def nthreads(self) -> "int":
        r"""nthreads(fft_vfc self) -> int"""
        return _fft_swig.fft_vfc_nthreads(self)

    def set_window(self, window: "pmt_vector_float") -> "bool":
        r"""set_window(fft_vfc self, pmt_vector_float window) -> bool"""
        return _fft_swig.fft_vfc_set_window(self, window)
    __swig_destroy__ = _fft_swig.delete_fft_vfc

# Register fft_vfc in _fft_swig:
_fft_swig.fft_vfc_swigregister(fft_vfc)

def fft_vfc_make(fft_size: "int", forward: "bool", window: "pmt_vector_float", nthreads: "int"=1) -> "gr::fft::fft_vfc::sptr":
    r"""
    fft_vfc_make(int fft_size, bool forward, pmt_vector_float window, int nthreads=1) -> fft_vfc_sptr
    Compute forward or reverse FFT. complex vector in / complex vector out.

    The FFT operation is defined for a vector  with  uniformly sampled points by





     is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


    The IFFT operation is defined for a vector  with  uniformly sampled points by





     is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


    , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

    Constructor Specific Documentation:



    Args:
        fft_size : N.
        forward : True performs FFT, False performs IFFT.
        window : Window function to be used.
        nthreads : Number of underlying threads.
    """
    return _fft_swig.fft_vfc_make(fft_size, forward, window, nthreads)

class goertzel_fc(object):
    r"""
    Goertzel single-bin DFT calculation.

    Constructor Specific Documentation:



    Args:
        rate : 
        len : 
        freq : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(rate: "int", len: "int", freq: "float") -> "gr::fft::goertzel_fc::sptr":
        r"""
        make(int rate, int len, float freq) -> goertzel_fc_sptr
        Goertzel single-bin DFT calculation.

        Constructor Specific Documentation:



        Args:
            rate : 
            len : 
            freq : 
        """
        return _fft_swig.goertzel_fc_make(rate, len, freq)

    def set_freq(self, freq: "float") -> "void":
        r"""set_freq(goertzel_fc self, float freq)"""
        return _fft_swig.goertzel_fc_set_freq(self, freq)

    def set_rate(self, rate: "int") -> "void":
        r"""set_rate(goertzel_fc self, int rate)"""
        return _fft_swig.goertzel_fc_set_rate(self, rate)

    def freq(self) -> "float":
        r"""freq(goertzel_fc self) -> float"""
        return _fft_swig.goertzel_fc_freq(self)

    def rate(self) -> "int":
        r"""rate(goertzel_fc self) -> int"""
        return _fft_swig.goertzel_fc_rate(self)
    __swig_destroy__ = _fft_swig.delete_goertzel_fc

# Register goertzel_fc in _fft_swig:
_fft_swig.goertzel_fc_swigregister(goertzel_fc)

def goertzel_fc_make(rate: "int", len: "int", freq: "float") -> "gr::fft::goertzel_fc::sptr":
    r"""
    goertzel_fc_make(int rate, int len, float freq) -> goertzel_fc_sptr
    Goertzel single-bin DFT calculation.

    Constructor Specific Documentation:



    Args:
        rate : 
        len : 
        freq : 
    """
    return _fft_swig.goertzel_fc_make(rate, len, freq)

class window(object):
    r"""Proxy of C++ gr::fft::window class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    WIN_HAMMING = _fft_swig.window_WIN_HAMMING
    
    WIN_HANN = _fft_swig.window_WIN_HANN
    
    WIN_BLACKMAN = _fft_swig.window_WIN_BLACKMAN
    
    WIN_RECTANGULAR = _fft_swig.window_WIN_RECTANGULAR
    
    WIN_KAISER = _fft_swig.window_WIN_KAISER
    
    WIN_BLACKMAN_hARRIS = _fft_swig.window_WIN_BLACKMAN_hARRIS
    
    WIN_BLACKMAN_HARRIS = _fft_swig.window_WIN_BLACKMAN_HARRIS
    
    WIN_BARTLETT = _fft_swig.window_WIN_BARTLETT
    
    WIN_FLATTOP = _fft_swig.window_WIN_FLATTOP
    

    @staticmethod
    def max_attenuation(type: "gr::fft::window::win_type", beta: "double"=6.76) -> "double":
        r"""
        max_attenuation(gr::fft::window::win_type type, double beta=6.76) -> double
        Given a window::win_type, this tells you the maximum attenuation you can expect.

        For most windows, this is a set value. For the Kaiser window, the attenuation is based on the value of beta. The actual relationship is a piece-wise exponential relationship to calculate beta from the desired attenuation and can be found on page 542 of Oppenheim and Schafer (Discrete-Time Signal Processing, 3rd edition). To simplify this function to solve for A given beta, we use a linear form that is exact for attenuation >= 50 dB.


        For an attenuation of 50 dB, beta = 4.55.


        For an attenuation of 70 dB, beta = 6.76.
        """
        return _fft_swig.window_max_attenuation(type, beta)

    @staticmethod
    def coswindow(*args) -> "std::vector< float,std::allocator< float > >":
        r"""
        coswindow(int ntaps, float c0, float c1, float c2) -> pmt_vector_float
        coswindow(int ntaps, float c0, float c1, float c2, float c3) -> pmt_vector_float
        coswindow(int ntaps, float c0, float c1, float c2, float c3, float c4) -> pmt_vector_float
        Helper function to build cosine-based windows. 3-coefficient version.
        """
        return _fft_swig.window_coswindow(*args)

    @staticmethod
    def rectangular(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        rectangular(int ntaps) -> pmt_vector_float
        Build a rectangular window.

        Taps are flat across the window.
        """
        return _fft_swig.window_rectangular(ntaps)

    @staticmethod
    def hamming(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        hamming(int ntaps) -> pmt_vector_float
        Build a Hamming window.

        See:
        """
        return _fft_swig.window_hamming(ntaps)

    @staticmethod
    def hann(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        hann(int ntaps) -> pmt_vector_float
        Build a Hann window (sometimes known as Hanning).

        See:
        """
        return _fft_swig.window_hann(ntaps)

    @staticmethod
    def hanning(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        hanning(int ntaps) -> pmt_vector_float
        Alias to build a Hann window.
        """
        return _fft_swig.window_hanning(ntaps)

    @staticmethod
    def blackman(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman(int ntaps) -> pmt_vector_float
        Build an exact Blackman window.

        See:
        """
        return _fft_swig.window_blackman(ntaps)

    @staticmethod
    def blackman2(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman2(int ntaps) -> pmt_vector_float
        Build Blackman window, variation 1.
        """
        return _fft_swig.window_blackman2(ntaps)

    @staticmethod
    def blackman3(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman3(int ntaps) -> pmt_vector_float
        Build Blackman window, variation 2.
        """
        return _fft_swig.window_blackman3(ntaps)

    @staticmethod
    def blackman4(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman4(int ntaps) -> pmt_vector_float
        Build Blackman window, variation 3.
        """
        return _fft_swig.window_blackman4(ntaps)

    @staticmethod
    def blackman_harris(ntaps: "int", atten: "int"=92) -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman_harris(int ntaps, int atten=92) -> pmt_vector_float
        Build a Blackman-harris window with a given attenuation.
        """
        return _fft_swig.window_blackman_harris(ntaps, atten)

    @staticmethod
    def blackmanharris(ntaps: "int", atten: "int"=92) -> "std::vector< float,std::allocator< float > >":
        r"""
        blackmanharris(int ntaps, int atten=92) -> pmt_vector_float
        Alias to gr::fft::window::blackman_harris.
        """
        return _fft_swig.window_blackmanharris(ntaps, atten)

    @staticmethod
    def nuttall(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        nuttall(int ntaps) -> pmt_vector_float
        Build a Nuttall (or Blackman-Nuttall) window.

        See:
        """
        return _fft_swig.window_nuttall(ntaps)

    @staticmethod
    def nuttal(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        nuttal(int ntaps) -> pmt_vector_float
        Deprecated: use nuttall window instead.
        """
        return _fft_swig.window_nuttal(ntaps)

    @staticmethod
    def blackman_nuttall(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman_nuttall(int ntaps) -> pmt_vector_float
        Alias to the Nuttall window.
        """
        return _fft_swig.window_blackman_nuttall(ntaps)

    @staticmethod
    def blackman_nuttal(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        blackman_nuttal(int ntaps) -> pmt_vector_float
        Deprecated: use blackman_nuttall window instead.
        """
        return _fft_swig.window_blackman_nuttal(ntaps)

    @staticmethod
    def nuttall_cfd(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        nuttall_cfd(int ntaps) -> pmt_vector_float
        Build a Nuttall continuous first derivative window.

        See:
        """
        return _fft_swig.window_nuttall_cfd(ntaps)

    @staticmethod
    def nuttal_cfd(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        nuttal_cfd(int ntaps) -> pmt_vector_float
        Deprecated: use nuttall_cfd window instead.
        """
        return _fft_swig.window_nuttal_cfd(ntaps)

    @staticmethod
    def flattop(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        flattop(int ntaps) -> pmt_vector_float
        Build a flat top window.

        See:
        """
        return _fft_swig.window_flattop(ntaps)

    @staticmethod
    def kaiser(ntaps: "int", beta: "double") -> "std::vector< float,std::allocator< float > >":
        r"""
        kaiser(int ntaps, double beta) -> pmt_vector_float
        Build a Kaiser window with a given beta.

        See:
        """
        return _fft_swig.window_kaiser(ntaps, beta)

    @staticmethod
    def bartlett(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        bartlett(int ntaps) -> pmt_vector_float
        Build a Barlett (triangular) window.

        See:
        """
        return _fft_swig.window_bartlett(ntaps)

    @staticmethod
    def welch(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""welch(int ntaps) -> pmt_vector_float"""
        return _fft_swig.window_welch(ntaps)

    @staticmethod
    def parzen(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        parzen(int ntaps) -> pmt_vector_float
        Build a Parzen (or de la Valle-Poussin) window.

        See:
        """
        return _fft_swig.window_parzen(ntaps)

    @staticmethod
    def exponential(ntaps: "int", d: "double") -> "std::vector< float,std::allocator< float > >":
        r"""
        exponential(int ntaps, double d) -> pmt_vector_float
        Build an exponential window with a given decay.

        See:
        """
        return _fft_swig.window_exponential(ntaps, d)

    @staticmethod
    def riemann(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
        r"""
        riemann(int ntaps) -> pmt_vector_float
        Build a Riemann window.

        See:
        """
        return _fft_swig.window_riemann(ntaps)

    @staticmethod
    def build(type: "gr::fft::window::win_type", ntaps: "int", beta: "double") -> "std::vector< float,std::allocator< float > >":
        r"""
        build(gr::fft::window::win_type type, int ntaps, double beta) -> pmt_vector_float
        Build a window using gr::fft::win_type to index the type of window desired.
        """
        return _fft_swig.window_build(type, ntaps, beta)

    def __init__(self):
        r"""__init__(window self) -> window"""
        _fft_swig.window_swiginit(self, _fft_swig.new_window())
    __swig_destroy__ = _fft_swig.delete_window

# Register window in _fft_swig:
_fft_swig.window_swigregister(window)

def window_max_attenuation(type: "gr::fft::window::win_type", beta: "double"=6.76) -> "double":
    r"""
    window_max_attenuation(gr::fft::window::win_type type, double beta=6.76) -> double
    Given a window::win_type, this tells you the maximum attenuation you can expect.

    For most windows, this is a set value. For the Kaiser window, the attenuation is based on the value of beta. The actual relationship is a piece-wise exponential relationship to calculate beta from the desired attenuation and can be found on page 542 of Oppenheim and Schafer (Discrete-Time Signal Processing, 3rd edition). To simplify this function to solve for A given beta, we use a linear form that is exact for attenuation >= 50 dB.


    For an attenuation of 50 dB, beta = 4.55.


    For an attenuation of 70 dB, beta = 6.76.
    """
    return _fft_swig.window_max_attenuation(type, beta)

def window_coswindow(*args) -> "std::vector< float,std::allocator< float > >":
    r"""
    window_coswindow(int ntaps, float c0, float c1, float c2) -> pmt_vector_float
    window_coswindow(int ntaps, float c0, float c1, float c2, float c3) -> pmt_vector_float
    window_coswindow(int ntaps, float c0, float c1, float c2, float c3, float c4) -> pmt_vector_float
    Helper function to build cosine-based windows. 3-coefficient version.
    """
    return _fft_swig.window_coswindow(*args)

def window_rectangular(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_rectangular(int ntaps) -> pmt_vector_float
    Build a rectangular window.

    Taps are flat across the window.
    """
    return _fft_swig.window_rectangular(ntaps)

def window_hamming(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_hamming(int ntaps) -> pmt_vector_float
    Build a Hamming window.

    See:
    """
    return _fft_swig.window_hamming(ntaps)

def window_hann(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_hann(int ntaps) -> pmt_vector_float
    Build a Hann window (sometimes known as Hanning).

    See:
    """
    return _fft_swig.window_hann(ntaps)

def window_hanning(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_hanning(int ntaps) -> pmt_vector_float
    Alias to build a Hann window.
    """
    return _fft_swig.window_hanning(ntaps)

def window_blackman(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman(int ntaps) -> pmt_vector_float
    Build an exact Blackman window.

    See:
    """
    return _fft_swig.window_blackman(ntaps)

def window_blackman2(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman2(int ntaps) -> pmt_vector_float
    Build Blackman window, variation 1.
    """
    return _fft_swig.window_blackman2(ntaps)

def window_blackman3(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman3(int ntaps) -> pmt_vector_float
    Build Blackman window, variation 2.
    """
    return _fft_swig.window_blackman3(ntaps)

def window_blackman4(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman4(int ntaps) -> pmt_vector_float
    Build Blackman window, variation 3.
    """
    return _fft_swig.window_blackman4(ntaps)

def window_blackman_harris(ntaps: "int", atten: "int"=92) -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman_harris(int ntaps, int atten=92) -> pmt_vector_float
    Build a Blackman-harris window with a given attenuation.
    """
    return _fft_swig.window_blackman_harris(ntaps, atten)

def window_blackmanharris(ntaps: "int", atten: "int"=92) -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackmanharris(int ntaps, int atten=92) -> pmt_vector_float
    Alias to gr::fft::window::blackman_harris.
    """
    return _fft_swig.window_blackmanharris(ntaps, atten)

def window_nuttall(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_nuttall(int ntaps) -> pmt_vector_float
    Build a Nuttall (or Blackman-Nuttall) window.

    See:
    """
    return _fft_swig.window_nuttall(ntaps)

def window_nuttal(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_nuttal(int ntaps) -> pmt_vector_float
    Deprecated: use nuttall window instead.
    """
    return _fft_swig.window_nuttal(ntaps)

def window_blackman_nuttall(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman_nuttall(int ntaps) -> pmt_vector_float
    Alias to the Nuttall window.
    """
    return _fft_swig.window_blackman_nuttall(ntaps)

def window_blackman_nuttal(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_blackman_nuttal(int ntaps) -> pmt_vector_float
    Deprecated: use blackman_nuttall window instead.
    """
    return _fft_swig.window_blackman_nuttal(ntaps)

def window_nuttall_cfd(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_nuttall_cfd(int ntaps) -> pmt_vector_float
    Build a Nuttall continuous first derivative window.

    See:
    """
    return _fft_swig.window_nuttall_cfd(ntaps)

def window_nuttal_cfd(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_nuttal_cfd(int ntaps) -> pmt_vector_float
    Deprecated: use nuttall_cfd window instead.
    """
    return _fft_swig.window_nuttal_cfd(ntaps)

def window_flattop(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_flattop(int ntaps) -> pmt_vector_float
    Build a flat top window.

    See:
    """
    return _fft_swig.window_flattop(ntaps)

def window_kaiser(ntaps: "int", beta: "double") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_kaiser(int ntaps, double beta) -> pmt_vector_float
    Build a Kaiser window with a given beta.

    See:
    """
    return _fft_swig.window_kaiser(ntaps, beta)

def window_bartlett(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_bartlett(int ntaps) -> pmt_vector_float
    Build a Barlett (triangular) window.

    See:
    """
    return _fft_swig.window_bartlett(ntaps)

def window_welch(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""window_welch(int ntaps) -> pmt_vector_float"""
    return _fft_swig.window_welch(ntaps)

def window_parzen(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_parzen(int ntaps) -> pmt_vector_float
    Build a Parzen (or de la Valle-Poussin) window.

    See:
    """
    return _fft_swig.window_parzen(ntaps)

def window_exponential(ntaps: "int", d: "double") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_exponential(int ntaps, double d) -> pmt_vector_float
    Build an exponential window with a given decay.

    See:
    """
    return _fft_swig.window_exponential(ntaps, d)

def window_riemann(ntaps: "int") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_riemann(int ntaps) -> pmt_vector_float
    Build a Riemann window.

    See:
    """
    return _fft_swig.window_riemann(ntaps)

def window_build(type: "gr::fft::window::win_type", ntaps: "int", beta: "double") -> "std::vector< float,std::allocator< float > >":
    r"""
    window_build(gr::fft::window::win_type type, int ntaps, double beta) -> pmt_vector_float
    Build a window using gr::fft::win_type to index the type of window desired.
    """
    return _fft_swig.window_build(type, ntaps, beta)

class fft_vcc_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::fft::fft_vcc > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(fft_vcc_sptr self) -> fft_vcc_sptr
        __init__(fft_vcc_sptr self, fft_vcc p) -> fft_vcc_sptr
        """
        _fft_swig.fft_vcc_sptr_swiginit(self, _fft_swig.new_fft_vcc_sptr(*args))

    def __deref__(self) -> "gr::fft::fft_vcc *":
        r"""__deref__(fft_vcc_sptr self) -> fft_vcc"""
        return _fft_swig.fft_vcc_sptr___deref__(self)
    __swig_destroy__ = _fft_swig.delete_fft_vcc_sptr

    def make(self, fft_size: "int", forward: "bool", window: "pmt_vector_float", shift: "bool"=False, nthreads: "int"=1) -> "gr::fft::fft_vcc::sptr":
        r"""
        make(fft_vcc_sptr self, int fft_size, bool forward, pmt_vector_float window, bool shift=False, int nthreads=1) -> fft_vcc_sptr
        Compute forward or reverse FFT. complex vector in / complex vector out.

        The FFT operation is defined for a vector  with  uniformly sampled points by





         is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


        The IFFT operation is defined for a vector  with  uniformly sampled points by





         is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


        , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

        Constructor Specific Documentation:



        Args:
            fft_size : N.
            forward : True performs FFT, False performs IFFT.
            window : Window function to be used.
            shift : True moves DC carrier to the middle.
            nthreads : Number of underlying threads.
        """
        return _fft_swig.fft_vcc_sptr_make(self, fft_size, forward, window, shift, nthreads)

    def set_nthreads(self, n: "int") -> "void":
        r"""set_nthreads(fft_vcc_sptr self, int n)"""
        return _fft_swig.fft_vcc_sptr_set_nthreads(self, n)

    def nthreads(self) -> "int":
        r"""nthreads(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_nthreads(self)

    def set_window(self, window: "pmt_vector_float") -> "bool":
        r"""set_window(fft_vcc_sptr self, pmt_vector_float window) -> bool"""
        return _fft_swig.fft_vcc_sptr_set_window(self, window)

    def history(self) -> "unsigned int":
        r"""history(fft_vcc_sptr self) -> unsigned int"""
        return _fft_swig.fft_vcc_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(fft_vcc_sptr self, int which, int delay)
        declare_sample_delay(fft_vcc_sptr self, unsigned int delay)
        """
        return _fft_swig.fft_vcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(fft_vcc_sptr self, int which) -> unsigned int"""
        return _fft_swig.fft_vcc_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(fft_vcc_sptr self, int multiple)"""
        return _fft_swig.fft_vcc_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(fft_vcc_sptr self) -> double"""
        return _fft_swig.fft_vcc_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(fft_vcc_sptr self) -> uint64_t"""
        return _fft_swig.fft_vcc_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(fft_vcc_sptr self) -> uint64_t"""
        return _fft_swig.fft_vcc_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(fft_vcc_sptr self) -> bool"""
        return _fft_swig.fft_vcc_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(fft_vcc_sptr self) -> bool"""
        return _fft_swig.fft_vcc_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(fft_vcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _fft_swig.fft_vcc_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(fft_vcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _fft_swig.fft_vcc_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(fft_vcc_sptr self, std::string level)"""
        return _fft_swig.fft_vcc_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(fft_vcc_sptr self) -> std::string"""
        return _fft_swig.fft_vcc_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(fft_vcc_sptr self, int m)"""
        return _fft_swig.fft_vcc_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(fft_vcc_sptr self)"""
        return _fft_swig.fft_vcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(fft_vcc_sptr self) -> bool"""
        return _fft_swig.fft_vcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(fft_vcc_sptr self, int m)"""
        return _fft_swig.fft_vcc_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(fft_vcc_sptr self, int i) -> long"""
        return _fft_swig.fft_vcc_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(fft_vcc_sptr self, long max_output_buffer)
        set_max_output_buffer(fft_vcc_sptr self, int port, long max_output_buffer)
        """
        return _fft_swig.fft_vcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(fft_vcc_sptr self, int i) -> long"""
        return _fft_swig.fft_vcc_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(fft_vcc_sptr self, long min_output_buffer)
        set_min_output_buffer(fft_vcc_sptr self, int port, long min_output_buffer)
        """
        return _fft_swig.fft_vcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(fft_vcc_sptr self, int which) -> float
        pc_input_buffers_full(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(fft_vcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(fft_vcc_sptr self, int which) -> float
        pc_input_buffers_full_var(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(fft_vcc_sptr self, int which) -> float
        pc_output_buffers_full(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(fft_vcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(fft_vcc_sptr self, int which) -> float
        pc_output_buffers_full_var(fft_vcc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(fft_vcc_sptr self) -> float"""
        return _fft_swig.fft_vcc_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(fft_vcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fft_swig.fft_vcc_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(fft_vcc_sptr self)"""
        return _fft_swig.fft_vcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(fft_vcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fft_swig.fft_vcc_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(fft_vcc_sptr self) -> int"""
        return _fft_swig.fft_vcc_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(fft_vcc_sptr self, int priority) -> int"""
        return _fft_swig.fft_vcc_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(fft_vcc_sptr self) -> std::string"""
        return _fft_swig.fft_vcc_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(fft_vcc_sptr self) -> std::string"""
        return _fft_swig.fft_vcc_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(fft_vcc_sptr self) -> io_signature_sptr"""
        return _fft_swig.fft_vcc_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(fft_vcc_sptr self) -> io_signature_sptr"""
        return _fft_swig.fft_vcc_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(fft_vcc_sptr self) -> long"""
        return _fft_swig.fft_vcc_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(fft_vcc_sptr self) -> basic_block_sptr"""
        return _fft_swig.fft_vcc_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(fft_vcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _fft_swig.fft_vcc_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(fft_vcc_sptr self) -> std::string"""
        return _fft_swig.fft_vcc_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(fft_vcc_sptr self, std::string name)"""
        return _fft_swig.fft_vcc_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(fft_vcc_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _fft_swig.fft_vcc_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(fft_vcc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.fft_vcc_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(fft_vcc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.fft_vcc_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(fft_vcc_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _fft_swig.fft_vcc_sptr_message_subscribers(self, which_port)

# Register fft_vcc_sptr in _fft_swig:
_fft_swig.fft_vcc_sptr_swigregister(fft_vcc_sptr)


fft_vcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fft_vcc = fft_vcc.make;

class fft_vfc_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::fft::fft_vfc > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(fft_vfc_sptr self) -> fft_vfc_sptr
        __init__(fft_vfc_sptr self, fft_vfc p) -> fft_vfc_sptr
        """
        _fft_swig.fft_vfc_sptr_swiginit(self, _fft_swig.new_fft_vfc_sptr(*args))

    def __deref__(self) -> "gr::fft::fft_vfc *":
        r"""__deref__(fft_vfc_sptr self) -> fft_vfc"""
        return _fft_swig.fft_vfc_sptr___deref__(self)
    __swig_destroy__ = _fft_swig.delete_fft_vfc_sptr

    def make(self, fft_size: "int", forward: "bool", window: "pmt_vector_float", nthreads: "int"=1) -> "gr::fft::fft_vfc::sptr":
        r"""
        make(fft_vfc_sptr self, int fft_size, bool forward, pmt_vector_float window, int nthreads=1) -> fft_vfc_sptr
        Compute forward or reverse FFT. complex vector in / complex vector out.

        The FFT operation is defined for a vector  with  uniformly sampled points by





         is the the FFT transform of ,  is the imaginary unit,  and  range from  to .


        The IFFT operation is defined for a vector  with  uniformly sampled points by





         is the the inverse FFT transform of ,  is the imaginary unit,  and  range from  to .


        , that due to the underlying FFTW library, the output of a FFT followed by an IFFT (or the other way around) will be scaled i.e. .

        Constructor Specific Documentation:



        Args:
            fft_size : N.
            forward : True performs FFT, False performs IFFT.
            window : Window function to be used.
            nthreads : Number of underlying threads.
        """
        return _fft_swig.fft_vfc_sptr_make(self, fft_size, forward, window, nthreads)

    def set_nthreads(self, n: "int") -> "void":
        r"""set_nthreads(fft_vfc_sptr self, int n)"""
        return _fft_swig.fft_vfc_sptr_set_nthreads(self, n)

    def nthreads(self) -> "int":
        r"""nthreads(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_nthreads(self)

    def set_window(self, window: "pmt_vector_float") -> "bool":
        r"""set_window(fft_vfc_sptr self, pmt_vector_float window) -> bool"""
        return _fft_swig.fft_vfc_sptr_set_window(self, window)

    def history(self) -> "unsigned int":
        r"""history(fft_vfc_sptr self) -> unsigned int"""
        return _fft_swig.fft_vfc_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(fft_vfc_sptr self, int which, int delay)
        declare_sample_delay(fft_vfc_sptr self, unsigned int delay)
        """
        return _fft_swig.fft_vfc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(fft_vfc_sptr self, int which) -> unsigned int"""
        return _fft_swig.fft_vfc_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(fft_vfc_sptr self, int multiple)"""
        return _fft_swig.fft_vfc_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(fft_vfc_sptr self) -> double"""
        return _fft_swig.fft_vfc_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(fft_vfc_sptr self) -> uint64_t"""
        return _fft_swig.fft_vfc_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(fft_vfc_sptr self) -> uint64_t"""
        return _fft_swig.fft_vfc_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(fft_vfc_sptr self) -> bool"""
        return _fft_swig.fft_vfc_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(fft_vfc_sptr self) -> bool"""
        return _fft_swig.fft_vfc_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(fft_vfc_sptr self, unsigned int which_input) -> uint64_t"""
        return _fft_swig.fft_vfc_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(fft_vfc_sptr self, unsigned int which_output) -> uint64_t"""
        return _fft_swig.fft_vfc_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(fft_vfc_sptr self, std::string level)"""
        return _fft_swig.fft_vfc_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(fft_vfc_sptr self) -> std::string"""
        return _fft_swig.fft_vfc_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(fft_vfc_sptr self, int m)"""
        return _fft_swig.fft_vfc_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(fft_vfc_sptr self)"""
        return _fft_swig.fft_vfc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(fft_vfc_sptr self) -> bool"""
        return _fft_swig.fft_vfc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(fft_vfc_sptr self, int m)"""
        return _fft_swig.fft_vfc_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(fft_vfc_sptr self, int i) -> long"""
        return _fft_swig.fft_vfc_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(fft_vfc_sptr self, long max_output_buffer)
        set_max_output_buffer(fft_vfc_sptr self, int port, long max_output_buffer)
        """
        return _fft_swig.fft_vfc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(fft_vfc_sptr self, int i) -> long"""
        return _fft_swig.fft_vfc_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(fft_vfc_sptr self, long min_output_buffer)
        set_min_output_buffer(fft_vfc_sptr self, int port, long min_output_buffer)
        """
        return _fft_swig.fft_vfc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(fft_vfc_sptr self, int which) -> float
        pc_input_buffers_full(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(fft_vfc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(fft_vfc_sptr self, int which) -> float
        pc_input_buffers_full_var(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(fft_vfc_sptr self, int which) -> float
        pc_output_buffers_full(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(fft_vfc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(fft_vfc_sptr self, int which) -> float
        pc_output_buffers_full_var(fft_vfc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.fft_vfc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(fft_vfc_sptr self) -> float"""
        return _fft_swig.fft_vfc_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(fft_vfc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fft_swig.fft_vfc_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(fft_vfc_sptr self)"""
        return _fft_swig.fft_vfc_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(fft_vfc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fft_swig.fft_vfc_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(fft_vfc_sptr self) -> int"""
        return _fft_swig.fft_vfc_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(fft_vfc_sptr self, int priority) -> int"""
        return _fft_swig.fft_vfc_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(fft_vfc_sptr self) -> std::string"""
        return _fft_swig.fft_vfc_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(fft_vfc_sptr self) -> std::string"""
        return _fft_swig.fft_vfc_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(fft_vfc_sptr self) -> io_signature_sptr"""
        return _fft_swig.fft_vfc_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(fft_vfc_sptr self) -> io_signature_sptr"""
        return _fft_swig.fft_vfc_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(fft_vfc_sptr self) -> long"""
        return _fft_swig.fft_vfc_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(fft_vfc_sptr self) -> basic_block_sptr"""
        return _fft_swig.fft_vfc_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(fft_vfc_sptr self, int ninputs, int noutputs) -> bool"""
        return _fft_swig.fft_vfc_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(fft_vfc_sptr self) -> std::string"""
        return _fft_swig.fft_vfc_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(fft_vfc_sptr self, std::string name)"""
        return _fft_swig.fft_vfc_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(fft_vfc_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _fft_swig.fft_vfc_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(fft_vfc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.fft_vfc_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(fft_vfc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.fft_vfc_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(fft_vfc_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _fft_swig.fft_vfc_sptr_message_subscribers(self, which_port)

# Register fft_vfc_sptr in _fft_swig:
_fft_swig.fft_vfc_sptr_swigregister(fft_vfc_sptr)


fft_vfc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fft_vfc = fft_vfc.make;

class goertzel_fc_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::fft::goertzel_fc > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(goertzel_fc_sptr self) -> goertzel_fc_sptr
        __init__(goertzel_fc_sptr self, goertzel_fc p) -> goertzel_fc_sptr
        """
        _fft_swig.goertzel_fc_sptr_swiginit(self, _fft_swig.new_goertzel_fc_sptr(*args))

    def __deref__(self) -> "gr::fft::goertzel_fc *":
        r"""__deref__(goertzel_fc_sptr self) -> goertzel_fc"""
        return _fft_swig.goertzel_fc_sptr___deref__(self)
    __swig_destroy__ = _fft_swig.delete_goertzel_fc_sptr

    def make(self, rate: "int", len: "int", freq: "float") -> "gr::fft::goertzel_fc::sptr":
        r"""
        make(goertzel_fc_sptr self, int rate, int len, float freq) -> goertzel_fc_sptr
        Goertzel single-bin DFT calculation.

        Constructor Specific Documentation:



        Args:
            rate : 
            len : 
            freq : 
        """
        return _fft_swig.goertzel_fc_sptr_make(self, rate, len, freq)

    def set_freq(self, freq: "float") -> "void":
        r"""set_freq(goertzel_fc_sptr self, float freq)"""
        return _fft_swig.goertzel_fc_sptr_set_freq(self, freq)

    def set_rate(self, rate: "int") -> "void":
        r"""set_rate(goertzel_fc_sptr self, int rate)"""
        return _fft_swig.goertzel_fc_sptr_set_rate(self, rate)

    def freq(self) -> "float":
        r"""freq(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_freq(self)

    def rate(self) -> "int":
        r"""rate(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_rate(self)

    def history(self) -> "unsigned int":
        r"""history(goertzel_fc_sptr self) -> unsigned int"""
        return _fft_swig.goertzel_fc_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(goertzel_fc_sptr self, int which, int delay)
        declare_sample_delay(goertzel_fc_sptr self, unsigned int delay)
        """
        return _fft_swig.goertzel_fc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(goertzel_fc_sptr self, int which) -> unsigned int"""
        return _fft_swig.goertzel_fc_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(goertzel_fc_sptr self, int multiple)"""
        return _fft_swig.goertzel_fc_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(goertzel_fc_sptr self) -> double"""
        return _fft_swig.goertzel_fc_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(goertzel_fc_sptr self) -> uint64_t"""
        return _fft_swig.goertzel_fc_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(goertzel_fc_sptr self) -> uint64_t"""
        return _fft_swig.goertzel_fc_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(goertzel_fc_sptr self) -> bool"""
        return _fft_swig.goertzel_fc_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(goertzel_fc_sptr self) -> bool"""
        return _fft_swig.goertzel_fc_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(goertzel_fc_sptr self, unsigned int which_input) -> uint64_t"""
        return _fft_swig.goertzel_fc_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(goertzel_fc_sptr self, unsigned int which_output) -> uint64_t"""
        return _fft_swig.goertzel_fc_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(goertzel_fc_sptr self, std::string level)"""
        return _fft_swig.goertzel_fc_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(goertzel_fc_sptr self) -> std::string"""
        return _fft_swig.goertzel_fc_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(goertzel_fc_sptr self, int m)"""
        return _fft_swig.goertzel_fc_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(goertzel_fc_sptr self)"""
        return _fft_swig.goertzel_fc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(goertzel_fc_sptr self) -> bool"""
        return _fft_swig.goertzel_fc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(goertzel_fc_sptr self, int m)"""
        return _fft_swig.goertzel_fc_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(goertzel_fc_sptr self, int i) -> long"""
        return _fft_swig.goertzel_fc_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(goertzel_fc_sptr self, long max_output_buffer)
        set_max_output_buffer(goertzel_fc_sptr self, int port, long max_output_buffer)
        """
        return _fft_swig.goertzel_fc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(goertzel_fc_sptr self, int i) -> long"""
        return _fft_swig.goertzel_fc_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(goertzel_fc_sptr self, long min_output_buffer)
        set_min_output_buffer(goertzel_fc_sptr self, int port, long min_output_buffer)
        """
        return _fft_swig.goertzel_fc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(goertzel_fc_sptr self, int which) -> float
        pc_input_buffers_full(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(goertzel_fc_sptr self, int which) -> float
        pc_input_buffers_full_avg(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(goertzel_fc_sptr self, int which) -> float
        pc_input_buffers_full_var(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(goertzel_fc_sptr self, int which) -> float
        pc_output_buffers_full(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(goertzel_fc_sptr self, int which) -> float
        pc_output_buffers_full_avg(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(goertzel_fc_sptr self, int which) -> float
        pc_output_buffers_full_var(goertzel_fc_sptr self) -> pmt_vector_float
        """
        return _fft_swig.goertzel_fc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(goertzel_fc_sptr self) -> float"""
        return _fft_swig.goertzel_fc_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(goertzel_fc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fft_swig.goertzel_fc_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(goertzel_fc_sptr self)"""
        return _fft_swig.goertzel_fc_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(goertzel_fc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fft_swig.goertzel_fc_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(goertzel_fc_sptr self) -> int"""
        return _fft_swig.goertzel_fc_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(goertzel_fc_sptr self, int priority) -> int"""
        return _fft_swig.goertzel_fc_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(goertzel_fc_sptr self) -> std::string"""
        return _fft_swig.goertzel_fc_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(goertzel_fc_sptr self) -> std::string"""
        return _fft_swig.goertzel_fc_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(goertzel_fc_sptr self) -> io_signature_sptr"""
        return _fft_swig.goertzel_fc_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(goertzel_fc_sptr self) -> io_signature_sptr"""
        return _fft_swig.goertzel_fc_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(goertzel_fc_sptr self) -> long"""
        return _fft_swig.goertzel_fc_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(goertzel_fc_sptr self) -> basic_block_sptr"""
        return _fft_swig.goertzel_fc_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(goertzel_fc_sptr self, int ninputs, int noutputs) -> bool"""
        return _fft_swig.goertzel_fc_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(goertzel_fc_sptr self) -> std::string"""
        return _fft_swig.goertzel_fc_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(goertzel_fc_sptr self, std::string name)"""
        return _fft_swig.goertzel_fc_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(goertzel_fc_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _fft_swig.goertzel_fc_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(goertzel_fc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.goertzel_fc_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(goertzel_fc_sptr self) -> swig_pmt_ptr"""
        return _fft_swig.goertzel_fc_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(goertzel_fc_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _fft_swig.goertzel_fc_sptr_message_subscribers(self, which_port)

# Register goertzel_fc_sptr in _fft_swig:
_fft_swig.goertzel_fc_sptr_swigregister(goertzel_fc_sptr)


goertzel_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
goertzel_fc = goertzel_fc.make;



