# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _blocks_swig1
else:
    import _blocks_swig1

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def high_res_timer_now() -> "gr::high_res_timer_type":
    r"""high_res_timer_now() -> gr::high_res_timer_type"""
    return _blocks_swig1.high_res_timer_now()

def high_res_timer_now_perfmon() -> "gr::high_res_timer_type":
    r"""high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
    return _blocks_swig1.high_res_timer_now_perfmon()

def high_res_timer_tps() -> "gr::high_res_timer_type":
    r"""high_res_timer_tps() -> gr::high_res_timer_type"""
    return _blocks_swig1.high_res_timer_tps()

def high_res_timer_epoch() -> "gr::high_res_timer_type":
    r"""high_res_timer_epoch() -> gr::high_res_timer_type"""
    return _blocks_swig1.high_res_timer_epoch()
class vector_map(object):
    r"""
    Maps elements from a set of input vectors to a set of output vectors.

    If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:


    out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]


    That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

    Constructor Specific Documentation:

    Build a vector map block.

    Args:
        item_size : (integer) size of vector elements
        in_vlens : (vector of integers) number of elements in each input vector
        mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(item_size: "size_t", in_vlens: "gr_vsize_t", mapping: "gr_vvvsize_t") -> "gr::blocks::vector_map::sptr":
        r"""
        make(size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr
        Maps elements from a set of input vectors to a set of output vectors.

        If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:


        out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]


        That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

        Constructor Specific Documentation:

        Build a vector map block.

        Args:
            item_size : (integer) size of vector elements
            in_vlens : (vector of integers) number of elements in each input vector
            mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
        """
        return _blocks_swig1.vector_map_make(item_size, in_vlens, mapping)

    def set_mapping(self, mapping: "gr_vvvsize_t") -> "void":
        r"""set_mapping(vector_map self, gr_vvvsize_t mapping)"""
        return _blocks_swig1.vector_map_set_mapping(self, mapping)
    __swig_destroy__ = _blocks_swig1.delete_vector_map

# Register vector_map in _blocks_swig1:
_blocks_swig1.vector_map_swigregister(vector_map)

def vector_map_make(item_size: "size_t", in_vlens: "gr_vsize_t", mapping: "gr_vvvsize_t") -> "gr::blocks::vector_map::sptr":
    r"""
    vector_map_make(size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr
    Maps elements from a set of input vectors to a set of output vectors.

    If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:


    out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]


    That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

    Constructor Specific Documentation:

    Build a vector map block.

    Args:
        item_size : (integer) size of vector elements
        in_vlens : (vector of integers) number of elements in each input vector
        mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
    """
    return _blocks_swig1.vector_map_make(item_size, in_vlens, mapping)

class vector_to_stream(object):
    r"""
    convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

    Constructor Specific Documentation:

    Make vector-to-stream block

    Args:
        itemsize : the item size of the stream
        nitems_per_block : number of items per vector (vector size)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def make(itemsize: "size_t", nitems_per_block: "size_t") -> "gr::blocks::vector_to_stream::sptr":
        r"""
        make(size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr
        convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

        Constructor Specific Documentation:

        Make vector-to-stream block

        Args:
            itemsize : the item size of the stream
            nitems_per_block : number of items per vector (vector size)
        """
        return _blocks_swig1.vector_to_stream_make(itemsize, nitems_per_block)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_stream

# Register vector_to_stream in _blocks_swig1:
_blocks_swig1.vector_to_stream_swigregister(vector_to_stream)

def vector_to_stream_make(itemsize: "size_t", nitems_per_block: "size_t") -> "gr::blocks::vector_to_stream::sptr":
    r"""
    vector_to_stream_make(size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr
    convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

    Constructor Specific Documentation:

    Make vector-to-stream block

    Args:
        itemsize : the item size of the stream
        nitems_per_block : number of items per vector (vector size)
    """
    return _blocks_swig1.vector_to_stream_make(itemsize, nitems_per_block)

class vector_to_streams(object):
    r"""
    Convert 1 stream of vectors of length N to N streams of items.

    Constructor Specific Documentation:

    Make vector-to-streams block

    Args:
        itemsize : the item size of the stream
        nstreams : number of items per vector (vector size and number of streams produced)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def make(itemsize: "size_t", nstreams: "size_t") -> "gr::blocks::vector_to_streams::sptr":
        r"""
        make(size_t itemsize, size_t nstreams) -> vector_to_streams_sptr
        Convert 1 stream of vectors of length N to N streams of items.

        Constructor Specific Documentation:

        Make vector-to-streams block

        Args:
            itemsize : the item size of the stream
            nstreams : number of items per vector (vector size and number of streams produced)
        """
        return _blocks_swig1.vector_to_streams_make(itemsize, nstreams)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_streams

# Register vector_to_streams in _blocks_swig1:
_blocks_swig1.vector_to_streams_swigregister(vector_to_streams)

def vector_to_streams_make(itemsize: "size_t", nstreams: "size_t") -> "gr::blocks::vector_to_streams::sptr":
    r"""
    vector_to_streams_make(size_t itemsize, size_t nstreams) -> vector_to_streams_sptr
    Convert 1 stream of vectors of length N to N streams of items.

    Constructor Specific Documentation:

    Make vector-to-streams block

    Args:
        itemsize : the item size of the stream
        nstreams : number of items per vector (vector size and number of streams produced)
    """
    return _blocks_swig1.vector_to_streams_make(itemsize, nstreams)

class wavfile_sink(object):
    r"""
    Write stream to a Microsoft PCM (.wav) file.

    Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        n_channels : 
        sample_rate : 
        bits_per_sample : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(filename: "char const *", n_channels: "int", sample_rate: "unsigned int", bits_per_sample: "int"=16) -> "gr::blocks::wavfile_sink::sptr":
        r"""
        make(char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr
        Write stream to a Microsoft PCM (.wav) file.

        Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            n_channels : 
            sample_rate : 
            bits_per_sample : 
        """
        return _blocks_swig1.wavfile_sink_make(filename, n_channels, sample_rate, bits_per_sample)

    def open(self, filename: "char const *") -> "bool":
        r"""
        open(wavfile_sink self, char const * filename) -> bool
        Opens a new file and writes a WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_open(self, filename)

    def close(self) -> "void":
        r"""
        close(wavfile_sink self)
        Closes the currently active file and completes the WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_close(self)

    def set_sample_rate(self, sample_rate: "unsigned int") -> "void":
        r"""
        set_sample_rate(wavfile_sink self, unsigned int sample_rate)
        Set the sample rate. This will not affect the WAV file currently opened. Any following open() calls will use this new sample rate.
        """
        return _blocks_swig1.wavfile_sink_set_sample_rate(self, sample_rate)

    def set_bits_per_sample(self, bits_per_sample: "int") -> "void":
        r"""
        set_bits_per_sample(wavfile_sink self, int bits_per_sample)
        Set bits per sample. This will not affect the WAV file currently opened (see set_sample_rate()). If the value is neither 8 nor 16, the call is ignored and the current value is kept.
        """
        return _blocks_swig1.wavfile_sink_set_bits_per_sample(self, bits_per_sample)
    __swig_destroy__ = _blocks_swig1.delete_wavfile_sink

# Register wavfile_sink in _blocks_swig1:
_blocks_swig1.wavfile_sink_swigregister(wavfile_sink)

def wavfile_sink_make(filename: "char const *", n_channels: "int", sample_rate: "unsigned int", bits_per_sample: "int"=16) -> "gr::blocks::wavfile_sink::sptr":
    r"""
    wavfile_sink_make(char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr
    Write stream to a Microsoft PCM (.wav) file.

    Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        n_channels : 
        sample_rate : 
        bits_per_sample : 
    """
    return _blocks_swig1.wavfile_sink_make(filename, n_channels, sample_rate, bits_per_sample)

class wavfile_source(object):
    r"""
    Read stream from a Microsoft PCM (.wav) file, output floats.

    Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        repeat : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(filename: "char const *", repeat: "bool"=False) -> "gr::blocks::wavfile_source::sptr":
        r"""
        make(char const * filename, bool repeat=False) -> wavfile_source_sptr
        Read stream from a Microsoft PCM (.wav) file, output floats.

        Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            repeat : 
        """
        return _blocks_swig1.wavfile_source_make(filename, repeat)

    def sample_rate(self) -> "unsigned int":
        r"""
        sample_rate(wavfile_source self) -> unsigned int
        Read the sample rate as specified in the wav file header.
        """
        return _blocks_swig1.wavfile_source_sample_rate(self)

    def bits_per_sample(self) -> "int":
        r"""
        bits_per_sample(wavfile_source self) -> int
        Return the number of bits per sample as specified in the wav file header. Only 8 or 16 bit are supported here.
        """
        return _blocks_swig1.wavfile_source_bits_per_sample(self)

    def channels(self) -> "int":
        r"""
        channels(wavfile_source self) -> int
        Return the number of channels in the wav file as specified in the wav file header. This is also the max number of outputs you can have.
        """
        return _blocks_swig1.wavfile_source_channels(self)
    __swig_destroy__ = _blocks_swig1.delete_wavfile_source

# Register wavfile_source in _blocks_swig1:
_blocks_swig1.wavfile_source_swigregister(wavfile_source)

def wavfile_source_make(filename: "char const *", repeat: "bool"=False) -> "gr::blocks::wavfile_source::sptr":
    r"""
    wavfile_source_make(char const * filename, bool repeat=False) -> wavfile_source_sptr
    Read stream from a Microsoft PCM (.wav) file, output floats.

    Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        repeat : 
    """
    return _blocks_swig1.wavfile_source_make(filename, repeat)

class vector_map_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_map > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_map_sptr self) -> vector_map_sptr
        __init__(vector_map_sptr self, vector_map p) -> vector_map_sptr
        """
        _blocks_swig1.vector_map_sptr_swiginit(self, _blocks_swig1.new_vector_map_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_map *":
        r"""__deref__(vector_map_sptr self) -> vector_map"""
        return _blocks_swig1.vector_map_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_map_sptr

    def make(self, item_size: "size_t", in_vlens: "gr_vsize_t", mapping: "gr_vvvsize_t") -> "gr::blocks::vector_map::sptr":
        r"""
        make(vector_map_sptr self, size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr
        Maps elements from a set of input vectors to a set of output vectors.

        If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:


        out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]


        That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

        Constructor Specific Documentation:

        Build a vector map block.

        Args:
            item_size : (integer) size of vector elements
            in_vlens : (vector of integers) number of elements in each input vector
            mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
        """
        return _blocks_swig1.vector_map_sptr_make(self, item_size, in_vlens, mapping)

    def set_mapping(self, mapping: "gr_vvvsize_t") -> "void":
        r"""set_mapping(vector_map_sptr self, gr_vvvsize_t mapping)"""
        return _blocks_swig1.vector_map_sptr_set_mapping(self, mapping)

    def history(self) -> "unsigned int":
        r"""history(vector_map_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_map_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_map_sptr self, int which, int delay)
        declare_sample_delay(vector_map_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_map_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_map_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_map_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_map_sptr self, int multiple)"""
        return _blocks_swig1.vector_map_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_map_sptr self) -> double"""
        return _blocks_swig1.vector_map_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_map_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_map_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_map_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_map_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_map_sptr self, std::string level)"""
        return _blocks_swig1.vector_map_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_map_sptr self, int m)"""
        return _blocks_swig1.vector_map_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_map_sptr self)"""
        return _blocks_swig1.vector_map_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_map_sptr self, int m)"""
        return _blocks_swig1.vector_map_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_map_sptr self, int i) -> long"""
        return _blocks_swig1.vector_map_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_map_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_map_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_map_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_map_sptr self, int i) -> long"""
        return _blocks_swig1.vector_map_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_map_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_map_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_map_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_map_sptr self, int which) -> float
        pc_input_buffers_full(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_map_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_map_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_map_sptr self, int which) -> float
        pc_output_buffers_full(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_map_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_map_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_map_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_map_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_map_sptr self)"""
        return _blocks_swig1.vector_map_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_map_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_map_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_map_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_map_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_map_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_map_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_map_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_map_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_map_sptr self) -> long"""
        return _blocks_swig1.vector_map_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_map_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_map_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_map_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_map_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_map_sptr self, std::string name)"""
        return _blocks_swig1.vector_map_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_map_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_map_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_map_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_map_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_map_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_map_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_map_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_map_sptr_message_subscribers(self, which_port)

# Register vector_map_sptr in _blocks_swig1:
_blocks_swig1.vector_map_sptr_swigregister(vector_map_sptr)


vector_map_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_map = vector_map.make;

class vector_to_stream_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_to_stream > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_to_stream_sptr self) -> vector_to_stream_sptr
        __init__(vector_to_stream_sptr self, vector_to_stream p) -> vector_to_stream_sptr
        """
        _blocks_swig1.vector_to_stream_sptr_swiginit(self, _blocks_swig1.new_vector_to_stream_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_to_stream *":
        r"""__deref__(vector_to_stream_sptr self) -> vector_to_stream"""
        return _blocks_swig1.vector_to_stream_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_stream_sptr

    def make(self, itemsize: "size_t", nitems_per_block: "size_t") -> "gr::blocks::vector_to_stream::sptr":
        r"""
        make(vector_to_stream_sptr self, size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr
        convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

        Constructor Specific Documentation:

        Make vector-to-stream block

        Args:
            itemsize : the item size of the stream
            nitems_per_block : number of items per vector (vector size)
        """
        return _blocks_swig1.vector_to_stream_sptr_make(self, itemsize, nitems_per_block)

    def history(self) -> "unsigned int":
        r"""history(vector_to_stream_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_to_stream_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_to_stream_sptr self, int which, int delay)
        declare_sample_delay(vector_to_stream_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_to_stream_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_to_stream_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_to_stream_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_to_stream_sptr self, int multiple)"""
        return _blocks_swig1.vector_to_stream_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_to_stream_sptr self) -> double"""
        return _blocks_swig1.vector_to_stream_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_to_stream_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_to_stream_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_to_stream_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_to_stream_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_to_stream_sptr self, std::string level)"""
        return _blocks_swig1.vector_to_stream_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_to_stream_sptr self, int m)"""
        return _blocks_swig1.vector_to_stream_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_to_stream_sptr self)"""
        return _blocks_swig1.vector_to_stream_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_to_stream_sptr self, int m)"""
        return _blocks_swig1.vector_to_stream_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_to_stream_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_to_stream_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_to_stream_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_to_stream_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_to_stream_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_to_stream_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_to_stream_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_to_stream_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_to_stream_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_to_stream_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_to_stream_sptr self)"""
        return _blocks_swig1.vector_to_stream_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_to_stream_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_to_stream_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_to_stream_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_to_stream_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_to_stream_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_to_stream_sptr self) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_to_stream_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_to_stream_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_to_stream_sptr self, std::string name)"""
        return _blocks_swig1.vector_to_stream_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_to_stream_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_to_stream_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_to_stream_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_to_stream_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_to_stream_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_subscribers(self, which_port)

# Register vector_to_stream_sptr in _blocks_swig1:
_blocks_swig1.vector_to_stream_sptr_swigregister(vector_to_stream_sptr)


vector_to_stream_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_to_stream = vector_to_stream.make;

class vector_to_streams_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_to_streams > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_to_streams_sptr self) -> vector_to_streams_sptr
        __init__(vector_to_streams_sptr self, vector_to_streams p) -> vector_to_streams_sptr
        """
        _blocks_swig1.vector_to_streams_sptr_swiginit(self, _blocks_swig1.new_vector_to_streams_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_to_streams *":
        r"""__deref__(vector_to_streams_sptr self) -> vector_to_streams"""
        return _blocks_swig1.vector_to_streams_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_streams_sptr

    def make(self, itemsize: "size_t", nstreams: "size_t") -> "gr::blocks::vector_to_streams::sptr":
        r"""
        make(vector_to_streams_sptr self, size_t itemsize, size_t nstreams) -> vector_to_streams_sptr
        Convert 1 stream of vectors of length N to N streams of items.

        Constructor Specific Documentation:

        Make vector-to-streams block

        Args:
            itemsize : the item size of the stream
            nstreams : number of items per vector (vector size and number of streams produced)
        """
        return _blocks_swig1.vector_to_streams_sptr_make(self, itemsize, nstreams)

    def history(self) -> "unsigned int":
        r"""history(vector_to_streams_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_to_streams_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_to_streams_sptr self, int which, int delay)
        declare_sample_delay(vector_to_streams_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_to_streams_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_to_streams_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_to_streams_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_to_streams_sptr self, int multiple)"""
        return _blocks_swig1.vector_to_streams_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_to_streams_sptr self) -> double"""
        return _blocks_swig1.vector_to_streams_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_to_streams_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_to_streams_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_to_streams_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_to_streams_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_to_streams_sptr self, std::string level)"""
        return _blocks_swig1.vector_to_streams_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_to_streams_sptr self, int m)"""
        return _blocks_swig1.vector_to_streams_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_to_streams_sptr self)"""
        return _blocks_swig1.vector_to_streams_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_to_streams_sptr self, int m)"""
        return _blocks_swig1.vector_to_streams_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_to_streams_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_to_streams_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_to_streams_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_to_streams_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_to_streams_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_to_streams_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_to_streams_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_to_streams_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_to_streams_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_to_streams_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_to_streams_sptr self)"""
        return _blocks_swig1.vector_to_streams_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_to_streams_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_to_streams_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_to_streams_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_to_streams_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_to_streams_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_to_streams_sptr self) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_to_streams_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_to_streams_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_to_streams_sptr self, std::string name)"""
        return _blocks_swig1.vector_to_streams_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_to_streams_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_to_streams_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_to_streams_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_to_streams_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_to_streams_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_subscribers(self, which_port)

# Register vector_to_streams_sptr in _blocks_swig1:
_blocks_swig1.vector_to_streams_sptr_swigregister(vector_to_streams_sptr)


vector_to_streams_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_to_streams = vector_to_streams.make;

class vector_insert_b(object):
    r"""
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(data: "std::vector< std::uint8_t,std::allocator< std::uint8_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< unsigned char >::sptr":
        r"""
        make(std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, int periodicity, int offset=0) -> vector_insert_b_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_b_make(data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_b self)"""
        return _blocks_swig1.vector_insert_b_rewind(self)

    def set_data(self, data: "std::vector< std::uint8_t,std::allocator< std::uint8_t > > const &") -> "void":
        r"""set_data(vector_insert_b self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data)"""
        return _blocks_swig1.vector_insert_b_set_data(self, data)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_b

# Register vector_insert_b in _blocks_swig1:
_blocks_swig1.vector_insert_b_swigregister(vector_insert_b)

def vector_insert_b_make(data: "std::vector< std::uint8_t,std::allocator< std::uint8_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< unsigned char >::sptr":
    r"""
    vector_insert_b_make(std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, int periodicity, int offset=0) -> vector_insert_b_sptr
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    return _blocks_swig1.vector_insert_b_make(data, periodicity, offset)

class vector_insert_b_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_insert< std::uint8_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_insert_b_sptr self) -> vector_insert_b_sptr
        __init__(vector_insert_b_sptr self, vector_insert_b p) -> vector_insert_b_sptr
        """
        _blocks_swig1.vector_insert_b_sptr_swiginit(self, _blocks_swig1.new_vector_insert_b_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_insert< std::uint8_t > *":
        r"""__deref__(vector_insert_b_sptr self) -> vector_insert_b"""
        return _blocks_swig1.vector_insert_b_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_b_sptr

    def make(self, data: "std::vector< std::uint8_t,std::allocator< std::uint8_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< unsigned char >::sptr":
        r"""
        make(vector_insert_b_sptr self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, int periodicity, int offset=0) -> vector_insert_b_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_b_sptr_make(self, data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_rewind(self)

    def set_data(self, data: "std::vector< std::uint8_t,std::allocator< std::uint8_t > > const &") -> "void":
        r"""set_data(vector_insert_b_sptr self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data)"""
        return _blocks_swig1.vector_insert_b_sptr_set_data(self, data)

    def history(self) -> "unsigned int":
        r"""history(vector_insert_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_b_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_insert_b_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_insert_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_b_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_insert_b_sptr self, int multiple)"""
        return _blocks_swig1.vector_insert_b_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_insert_b_sptr self) -> double"""
        return _blocks_swig1.vector_insert_b_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_insert_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_insert_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_insert_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_insert_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_insert_b_sptr self, std::string level)"""
        return _blocks_swig1.vector_insert_b_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_insert_b_sptr self, int m)"""
        return _blocks_swig1.vector_insert_b_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_insert_b_sptr self, int m)"""
        return _blocks_swig1.vector_insert_b_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_insert_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_insert_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_insert_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_insert_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_insert_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_b_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_insert_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_b_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_insert_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_insert_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_insert_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_insert_b_sptr self) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_insert_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_insert_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_insert_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_b_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_insert_b_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_insert_b_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_insert_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_insert_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_insert_b_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_subscribers(self, which_port)

# Register vector_insert_b_sptr in _blocks_swig1:
_blocks_swig1.vector_insert_b_sptr_swigregister(vector_insert_b_sptr)


vector_insert_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_b = vector_insert_b.make

class vector_insert_s(object):
    r"""
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(data: "std::vector< std::int16_t,std::allocator< std::int16_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< short >::sptr":
        r"""
        make(std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_s_make(data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_s self)"""
        return _blocks_swig1.vector_insert_s_rewind(self)

    def set_data(self, data: "std::vector< std::int16_t,std::allocator< std::int16_t > > const &") -> "void":
        r"""set_data(vector_insert_s self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data)"""
        return _blocks_swig1.vector_insert_s_set_data(self, data)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_s

# Register vector_insert_s in _blocks_swig1:
_blocks_swig1.vector_insert_s_swigregister(vector_insert_s)

def vector_insert_s_make(data: "std::vector< std::int16_t,std::allocator< std::int16_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< short >::sptr":
    r"""
    vector_insert_s_make(std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    return _blocks_swig1.vector_insert_s_make(data, periodicity, offset)

class vector_insert_s_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_insert< std::int16_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_insert_s_sptr self) -> vector_insert_s_sptr
        __init__(vector_insert_s_sptr self, vector_insert_s p) -> vector_insert_s_sptr
        """
        _blocks_swig1.vector_insert_s_sptr_swiginit(self, _blocks_swig1.new_vector_insert_s_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_insert< std::int16_t > *":
        r"""__deref__(vector_insert_s_sptr self) -> vector_insert_s"""
        return _blocks_swig1.vector_insert_s_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_s_sptr

    def make(self, data: "std::vector< std::int16_t,std::allocator< std::int16_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< short >::sptr":
        r"""
        make(vector_insert_s_sptr self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_s_sptr_make(self, data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_rewind(self)

    def set_data(self, data: "std::vector< std::int16_t,std::allocator< std::int16_t > > const &") -> "void":
        r"""set_data(vector_insert_s_sptr self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data)"""
        return _blocks_swig1.vector_insert_s_sptr_set_data(self, data)

    def history(self) -> "unsigned int":
        r"""history(vector_insert_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_s_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_insert_s_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_insert_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_s_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_insert_s_sptr self, int multiple)"""
        return _blocks_swig1.vector_insert_s_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_insert_s_sptr self) -> double"""
        return _blocks_swig1.vector_insert_s_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_insert_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_insert_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_insert_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_insert_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_insert_s_sptr self, std::string level)"""
        return _blocks_swig1.vector_insert_s_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_insert_s_sptr self, int m)"""
        return _blocks_swig1.vector_insert_s_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_insert_s_sptr self, int m)"""
        return _blocks_swig1.vector_insert_s_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_insert_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_insert_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_insert_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_insert_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_insert_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_s_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_insert_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_s_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_insert_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_insert_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_insert_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_insert_s_sptr self) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_insert_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_insert_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_insert_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_s_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_insert_s_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_insert_s_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_insert_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_insert_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_insert_s_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_subscribers(self, which_port)

# Register vector_insert_s_sptr in _blocks_swig1:
_blocks_swig1.vector_insert_s_sptr_swigregister(vector_insert_s_sptr)


vector_insert_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_s = vector_insert_s.make

class vector_insert_i(object):
    r"""
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(data: "std::vector< std::int32_t,std::allocator< std::int32_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< int >::sptr":
        r"""
        make(std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_i_make(data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_i self)"""
        return _blocks_swig1.vector_insert_i_rewind(self)

    def set_data(self, data: "std::vector< std::int32_t,std::allocator< std::int32_t > > const &") -> "void":
        r"""set_data(vector_insert_i self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data)"""
        return _blocks_swig1.vector_insert_i_set_data(self, data)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_i

# Register vector_insert_i in _blocks_swig1:
_blocks_swig1.vector_insert_i_swigregister(vector_insert_i)

def vector_insert_i_make(data: "std::vector< std::int32_t,std::allocator< std::int32_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< int >::sptr":
    r"""
    vector_insert_i_make(std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    return _blocks_swig1.vector_insert_i_make(data, periodicity, offset)

class vector_insert_i_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_insert< std::int32_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_insert_i_sptr self) -> vector_insert_i_sptr
        __init__(vector_insert_i_sptr self, vector_insert_i p) -> vector_insert_i_sptr
        """
        _blocks_swig1.vector_insert_i_sptr_swiginit(self, _blocks_swig1.new_vector_insert_i_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_insert< std::int32_t > *":
        r"""__deref__(vector_insert_i_sptr self) -> vector_insert_i"""
        return _blocks_swig1.vector_insert_i_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_i_sptr

    def make(self, data: "std::vector< std::int32_t,std::allocator< std::int32_t > > const &", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< int >::sptr":
        r"""
        make(vector_insert_i_sptr self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_i_sptr_make(self, data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_rewind(self)

    def set_data(self, data: "std::vector< std::int32_t,std::allocator< std::int32_t > > const &") -> "void":
        r"""set_data(vector_insert_i_sptr self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data)"""
        return _blocks_swig1.vector_insert_i_sptr_set_data(self, data)

    def history(self) -> "unsigned int":
        r"""history(vector_insert_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_i_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_insert_i_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_insert_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_i_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_insert_i_sptr self, int multiple)"""
        return _blocks_swig1.vector_insert_i_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_insert_i_sptr self) -> double"""
        return _blocks_swig1.vector_insert_i_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_insert_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_insert_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_insert_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_insert_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_insert_i_sptr self, std::string level)"""
        return _blocks_swig1.vector_insert_i_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_insert_i_sptr self, int m)"""
        return _blocks_swig1.vector_insert_i_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_insert_i_sptr self, int m)"""
        return _blocks_swig1.vector_insert_i_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_insert_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_insert_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_insert_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_insert_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_insert_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_i_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_insert_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_i_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_insert_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_insert_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_insert_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_insert_i_sptr self) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_insert_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_insert_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_insert_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_i_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_insert_i_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_insert_i_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_insert_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_insert_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_insert_i_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_subscribers(self, which_port)

# Register vector_insert_i_sptr in _blocks_swig1:
_blocks_swig1.vector_insert_i_sptr_swigregister(vector_insert_i_sptr)


vector_insert_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_i = vector_insert_i.make

class vector_insert_f(object):
    r"""
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(data: "pmt_vector_float", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< float >::sptr":
        r"""
        make(pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_f_make(data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_f self)"""
        return _blocks_swig1.vector_insert_f_rewind(self)

    def set_data(self, data: "pmt_vector_float") -> "void":
        r"""set_data(vector_insert_f self, pmt_vector_float data)"""
        return _blocks_swig1.vector_insert_f_set_data(self, data)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_f

# Register vector_insert_f in _blocks_swig1:
_blocks_swig1.vector_insert_f_swigregister(vector_insert_f)

def vector_insert_f_make(data: "pmt_vector_float", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< float >::sptr":
    r"""
    vector_insert_f_make(pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    return _blocks_swig1.vector_insert_f_make(data, periodicity, offset)

class vector_insert_f_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_insert< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_insert_f_sptr self) -> vector_insert_f_sptr
        __init__(vector_insert_f_sptr self, vector_insert_f p) -> vector_insert_f_sptr
        """
        _blocks_swig1.vector_insert_f_sptr_swiginit(self, _blocks_swig1.new_vector_insert_f_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_insert< float > *":
        r"""__deref__(vector_insert_f_sptr self) -> vector_insert_f"""
        return _blocks_swig1.vector_insert_f_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_f_sptr

    def make(self, data: "pmt_vector_float", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< float >::sptr":
        r"""
        make(vector_insert_f_sptr self, pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_f_sptr_make(self, data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_rewind(self)

    def set_data(self, data: "pmt_vector_float") -> "void":
        r"""set_data(vector_insert_f_sptr self, pmt_vector_float data)"""
        return _blocks_swig1.vector_insert_f_sptr_set_data(self, data)

    def history(self) -> "unsigned int":
        r"""history(vector_insert_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_f_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_insert_f_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_insert_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_f_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_insert_f_sptr self, int multiple)"""
        return _blocks_swig1.vector_insert_f_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_insert_f_sptr self) -> double"""
        return _blocks_swig1.vector_insert_f_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_insert_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_insert_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_insert_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_insert_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_insert_f_sptr self, std::string level)"""
        return _blocks_swig1.vector_insert_f_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_insert_f_sptr self, int m)"""
        return _blocks_swig1.vector_insert_f_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_insert_f_sptr self, int m)"""
        return _blocks_swig1.vector_insert_f_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_insert_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_insert_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_insert_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_insert_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_insert_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_f_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_insert_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_f_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_insert_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_insert_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_insert_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_insert_f_sptr self) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_insert_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_insert_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_insert_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_f_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_insert_f_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_insert_f_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_insert_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_insert_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_insert_f_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_subscribers(self, which_port)

# Register vector_insert_f_sptr in _blocks_swig1:
_blocks_swig1.vector_insert_f_sptr_swigregister(vector_insert_f_sptr)


vector_insert_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_f = vector_insert_f.make

class vector_insert_c(object):
    r"""
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(data: "pmt_vector_cfloat", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< std::complex< float > >::sptr":
        r"""
        make(pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_c_make(data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_c self)"""
        return _blocks_swig1.vector_insert_c_rewind(self)

    def set_data(self, data: "pmt_vector_cfloat") -> "void":
        r"""set_data(vector_insert_c self, pmt_vector_cfloat data)"""
        return _blocks_swig1.vector_insert_c_set_data(self, data)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_c

# Register vector_insert_c in _blocks_swig1:
_blocks_swig1.vector_insert_c_swigregister(vector_insert_c)

def vector_insert_c_make(data: "pmt_vector_cfloat", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< std::complex< float > >::sptr":
    r"""
    vector_insert_c_make(pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr
    source of T's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    return _blocks_swig1.vector_insert_c_make(data, periodicity, offset)

class vector_insert_c_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_insert< gr_complex > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_insert_c_sptr self) -> vector_insert_c_sptr
        __init__(vector_insert_c_sptr self, vector_insert_c p) -> vector_insert_c_sptr
        """
        _blocks_swig1.vector_insert_c_sptr_swiginit(self, _blocks_swig1.new_vector_insert_c_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_insert< gr_complex > *":
        r"""__deref__(vector_insert_c_sptr self) -> vector_insert_c"""
        return _blocks_swig1.vector_insert_c_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_insert_c_sptr

    def make(self, data: "pmt_vector_cfloat", periodicity: "int", offset: "int"=0) -> "gr::blocks::vector_insert< std::complex< float > >::sptr":
        r"""
        make(vector_insert_c_sptr self, pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr
        source of T's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_c_sptr_make(self, data, periodicity, offset)

    def rewind(self) -> "void":
        r"""rewind(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_rewind(self)

    def set_data(self, data: "pmt_vector_cfloat") -> "void":
        r"""set_data(vector_insert_c_sptr self, pmt_vector_cfloat data)"""
        return _blocks_swig1.vector_insert_c_sptr_set_data(self, data)

    def history(self) -> "unsigned int":
        r"""history(vector_insert_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_c_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_insert_c_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_insert_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_c_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_insert_c_sptr self, int multiple)"""
        return _blocks_swig1.vector_insert_c_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_insert_c_sptr self) -> double"""
        return _blocks_swig1.vector_insert_c_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_insert_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_insert_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_insert_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_insert_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_insert_c_sptr self, std::string level)"""
        return _blocks_swig1.vector_insert_c_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_insert_c_sptr self, int m)"""
        return _blocks_swig1.vector_insert_c_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_insert_c_sptr self, int m)"""
        return _blocks_swig1.vector_insert_c_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_insert_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_insert_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_insert_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_insert_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_insert_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_c_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_insert_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_c_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_insert_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_insert_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_insert_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_insert_c_sptr self) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_insert_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_insert_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_insert_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_c_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_insert_c_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_insert_c_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_insert_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_insert_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_insert_c_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_subscribers(self, which_port)

# Register vector_insert_c_sptr in _blocks_swig1:
_blocks_swig1.vector_insert_c_sptr_swigregister(vector_insert_c_sptr)


vector_insert_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_c = vector_insert_c.make

class vector_sink_b(object):
    r"""
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< unsigned char >::sptr":
        r"""
        make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_b_make(vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_b self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_b_reset(self)

    def data(self) -> "std::vector< std::uint8_t,std::allocator< std::uint8_t > >":
        r"""data(vector_sink_b self) -> std::vector< std::uint8_t,std::allocator< std::uint8_t > >"""
        return _blocks_swig1.vector_sink_b_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_b self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_b_tags(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_b

# Register vector_sink_b in _blocks_swig1:
_blocks_swig1.vector_sink_b_swigregister(vector_sink_b)

def vector_sink_b_make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< unsigned char >::sptr":
    r"""
    vector_sink_b_make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    return _blocks_swig1.vector_sink_b_make(vlen, reserve_items)

class vector_sink_b_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_sink< std::uint8_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_sink_b_sptr self) -> vector_sink_b_sptr
        __init__(vector_sink_b_sptr self, vector_sink_b p) -> vector_sink_b_sptr
        """
        _blocks_swig1.vector_sink_b_sptr_swiginit(self, _blocks_swig1.new_vector_sink_b_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_sink< std::uint8_t > *":
        r"""__deref__(vector_sink_b_sptr self) -> vector_sink_b"""
        return _blocks_swig1.vector_sink_b_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_b_sptr

    def make(self, vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< unsigned char >::sptr":
        r"""
        make(vector_sink_b_sptr self, unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_b_sptr_make(self, vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_b_sptr self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_b_sptr_reset(self)

    def data(self) -> "std::vector< std::uint8_t,std::allocator< std::uint8_t > >":
        r"""data(vector_sink_b_sptr self) -> std::vector< std::uint8_t,std::allocator< std::uint8_t > >"""
        return _blocks_swig1.vector_sink_b_sptr_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_b_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_b_sptr_tags(self)

    def history(self) -> "unsigned int":
        r"""history(vector_sink_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_b_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_sink_b_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_sink_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_b_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_sink_b_sptr self, int multiple)"""
        return _blocks_swig1.vector_sink_b_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_sink_b_sptr self) -> double"""
        return _blocks_swig1.vector_sink_b_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_sink_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_sink_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_sink_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_sink_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_sink_b_sptr self, std::string level)"""
        return _blocks_swig1.vector_sink_b_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_sink_b_sptr self, int m)"""
        return _blocks_swig1.vector_sink_b_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_sink_b_sptr self)"""
        return _blocks_swig1.vector_sink_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_sink_b_sptr self, int m)"""
        return _blocks_swig1.vector_sink_b_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_sink_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_sink_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_sink_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_sink_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_sink_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_b_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_sink_b_sptr self)"""
        return _blocks_swig1.vector_sink_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_sink_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_b_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_sink_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_sink_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_sink_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_sink_b_sptr self) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_sink_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_sink_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_sink_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_b_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_sink_b_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_sink_b_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_sink_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_sink_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_sink_b_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_subscribers(self, which_port)

# Register vector_sink_b_sptr in _blocks_swig1:
_blocks_swig1.vector_sink_b_sptr_swigregister(vector_sink_b_sptr)


vector_sink_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_b = vector_sink_b.make

class vector_sink_s(object):
    r"""
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< short >::sptr":
        r"""
        make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_s_make(vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_s self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_s_reset(self)

    def data(self) -> "std::vector< std::int16_t,std::allocator< std::int16_t > >":
        r"""data(vector_sink_s self) -> std::vector< std::int16_t,std::allocator< std::int16_t > >"""
        return _blocks_swig1.vector_sink_s_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_s self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_s_tags(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_s

# Register vector_sink_s in _blocks_swig1:
_blocks_swig1.vector_sink_s_swigregister(vector_sink_s)

def vector_sink_s_make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< short >::sptr":
    r"""
    vector_sink_s_make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    return _blocks_swig1.vector_sink_s_make(vlen, reserve_items)

class vector_sink_s_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_sink< std::int16_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_sink_s_sptr self) -> vector_sink_s_sptr
        __init__(vector_sink_s_sptr self, vector_sink_s p) -> vector_sink_s_sptr
        """
        _blocks_swig1.vector_sink_s_sptr_swiginit(self, _blocks_swig1.new_vector_sink_s_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_sink< std::int16_t > *":
        r"""__deref__(vector_sink_s_sptr self) -> vector_sink_s"""
        return _blocks_swig1.vector_sink_s_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_s_sptr

    def make(self, vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< short >::sptr":
        r"""
        make(vector_sink_s_sptr self, unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_s_sptr_make(self, vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_s_sptr self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_s_sptr_reset(self)

    def data(self) -> "std::vector< std::int16_t,std::allocator< std::int16_t > >":
        r"""data(vector_sink_s_sptr self) -> std::vector< std::int16_t,std::allocator< std::int16_t > >"""
        return _blocks_swig1.vector_sink_s_sptr_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_s_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_s_sptr_tags(self)

    def history(self) -> "unsigned int":
        r"""history(vector_sink_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_s_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_sink_s_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_sink_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_s_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_sink_s_sptr self, int multiple)"""
        return _blocks_swig1.vector_sink_s_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_sink_s_sptr self) -> double"""
        return _blocks_swig1.vector_sink_s_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_sink_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_sink_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_sink_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_sink_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_sink_s_sptr self, std::string level)"""
        return _blocks_swig1.vector_sink_s_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_sink_s_sptr self, int m)"""
        return _blocks_swig1.vector_sink_s_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_sink_s_sptr self)"""
        return _blocks_swig1.vector_sink_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_sink_s_sptr self, int m)"""
        return _blocks_swig1.vector_sink_s_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_sink_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_sink_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_sink_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_sink_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_sink_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_s_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_sink_s_sptr self)"""
        return _blocks_swig1.vector_sink_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_sink_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_s_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_sink_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_sink_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_sink_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_sink_s_sptr self) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_sink_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_sink_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_sink_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_s_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_sink_s_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_sink_s_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_sink_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_sink_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_sink_s_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_subscribers(self, which_port)

# Register vector_sink_s_sptr in _blocks_swig1:
_blocks_swig1.vector_sink_s_sptr_swigregister(vector_sink_s_sptr)


vector_sink_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_s = vector_sink_s.make

class vector_sink_i(object):
    r"""
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< int >::sptr":
        r"""
        make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_i_make(vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_i self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_i_reset(self)

    def data(self) -> "std::vector< std::int32_t,std::allocator< std::int32_t > >":
        r"""data(vector_sink_i self) -> std::vector< std::int32_t,std::allocator< std::int32_t > >"""
        return _blocks_swig1.vector_sink_i_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_i self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_i_tags(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_i

# Register vector_sink_i in _blocks_swig1:
_blocks_swig1.vector_sink_i_swigregister(vector_sink_i)

def vector_sink_i_make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< int >::sptr":
    r"""
    vector_sink_i_make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    return _blocks_swig1.vector_sink_i_make(vlen, reserve_items)

class vector_sink_i_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_sink< std::int32_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_sink_i_sptr self) -> vector_sink_i_sptr
        __init__(vector_sink_i_sptr self, vector_sink_i p) -> vector_sink_i_sptr
        """
        _blocks_swig1.vector_sink_i_sptr_swiginit(self, _blocks_swig1.new_vector_sink_i_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_sink< std::int32_t > *":
        r"""__deref__(vector_sink_i_sptr self) -> vector_sink_i"""
        return _blocks_swig1.vector_sink_i_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_i_sptr

    def make(self, vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< int >::sptr":
        r"""
        make(vector_sink_i_sptr self, unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_i_sptr_make(self, vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_i_sptr self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_i_sptr_reset(self)

    def data(self) -> "std::vector< std::int32_t,std::allocator< std::int32_t > >":
        r"""data(vector_sink_i_sptr self) -> std::vector< std::int32_t,std::allocator< std::int32_t > >"""
        return _blocks_swig1.vector_sink_i_sptr_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_i_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_i_sptr_tags(self)

    def history(self) -> "unsigned int":
        r"""history(vector_sink_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_i_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_sink_i_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_sink_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_i_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_sink_i_sptr self, int multiple)"""
        return _blocks_swig1.vector_sink_i_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_sink_i_sptr self) -> double"""
        return _blocks_swig1.vector_sink_i_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_sink_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_sink_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_sink_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_sink_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_sink_i_sptr self, std::string level)"""
        return _blocks_swig1.vector_sink_i_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_sink_i_sptr self, int m)"""
        return _blocks_swig1.vector_sink_i_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_sink_i_sptr self)"""
        return _blocks_swig1.vector_sink_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_sink_i_sptr self, int m)"""
        return _blocks_swig1.vector_sink_i_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_sink_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_sink_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_sink_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_sink_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_sink_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_i_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_sink_i_sptr self)"""
        return _blocks_swig1.vector_sink_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_sink_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_i_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_sink_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_sink_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_sink_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_sink_i_sptr self) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_sink_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_sink_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_sink_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_i_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_sink_i_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_sink_i_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_sink_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_sink_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_sink_i_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_subscribers(self, which_port)

# Register vector_sink_i_sptr in _blocks_swig1:
_blocks_swig1.vector_sink_i_sptr_swigregister(vector_sink_i_sptr)


vector_sink_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_i = vector_sink_i.make

class vector_sink_f(object):
    r"""
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< float >::sptr":
        r"""
        make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_f_make(vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_f self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_f_reset(self)

    def data(self) -> "std::vector< float,std::allocator< float > >":
        r"""data(vector_sink_f self) -> pmt_vector_float"""
        return _blocks_swig1.vector_sink_f_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_f self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_f_tags(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_f

# Register vector_sink_f in _blocks_swig1:
_blocks_swig1.vector_sink_f_swigregister(vector_sink_f)

def vector_sink_f_make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< float >::sptr":
    r"""
    vector_sink_f_make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    return _blocks_swig1.vector_sink_f_make(vlen, reserve_items)

class vector_sink_f_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_sink< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_sink_f_sptr self) -> vector_sink_f_sptr
        __init__(vector_sink_f_sptr self, vector_sink_f p) -> vector_sink_f_sptr
        """
        _blocks_swig1.vector_sink_f_sptr_swiginit(self, _blocks_swig1.new_vector_sink_f_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_sink< float > *":
        r"""__deref__(vector_sink_f_sptr self) -> vector_sink_f"""
        return _blocks_swig1.vector_sink_f_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_f_sptr

    def make(self, vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< float >::sptr":
        r"""
        make(vector_sink_f_sptr self, unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_f_sptr_make(self, vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_f_sptr self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_f_sptr_reset(self)

    def data(self) -> "std::vector< float,std::allocator< float > >":
        r"""data(vector_sink_f_sptr self) -> pmt_vector_float"""
        return _blocks_swig1.vector_sink_f_sptr_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_f_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_f_sptr_tags(self)

    def history(self) -> "unsigned int":
        r"""history(vector_sink_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_f_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_sink_f_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_sink_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_f_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_sink_f_sptr self, int multiple)"""
        return _blocks_swig1.vector_sink_f_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_sink_f_sptr self) -> double"""
        return _blocks_swig1.vector_sink_f_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_sink_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_sink_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_sink_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_sink_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_sink_f_sptr self, std::string level)"""
        return _blocks_swig1.vector_sink_f_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_sink_f_sptr self, int m)"""
        return _blocks_swig1.vector_sink_f_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_sink_f_sptr self)"""
        return _blocks_swig1.vector_sink_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_sink_f_sptr self, int m)"""
        return _blocks_swig1.vector_sink_f_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_sink_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_sink_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_sink_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_sink_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_sink_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_f_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_sink_f_sptr self)"""
        return _blocks_swig1.vector_sink_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_sink_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_f_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_sink_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_sink_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_sink_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_sink_f_sptr self) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_sink_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_sink_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_sink_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_f_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_sink_f_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_sink_f_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_sink_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_sink_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_sink_f_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_subscribers(self, which_port)

# Register vector_sink_f_sptr in _blocks_swig1:
_blocks_swig1.vector_sink_f_sptr_swigregister(vector_sink_f_sptr)


vector_sink_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_f = vector_sink_f.make

class vector_sink_c(object):
    r"""
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< std::complex< float > >::sptr":
        r"""
        make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_c_make(vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_c self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_c_reset(self)

    def data(self) -> "std::vector< std::complex< float >,std::allocator< std::complex< float > > >":
        r"""data(vector_sink_c self) -> pmt_vector_cfloat"""
        return _blocks_swig1.vector_sink_c_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_c self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_c_tags(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_c

# Register vector_sink_c in _blocks_swig1:
_blocks_swig1.vector_sink_c_swigregister(vector_sink_c)

def vector_sink_c_make(vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< std::complex< float > >::sptr":
    r"""
    vector_sink_c_make(unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr
    T sink that writes to a vector.

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    return _blocks_swig1.vector_sink_c_make(vlen, reserve_items)

class vector_sink_c_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_sink< gr_complex > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_sink_c_sptr self) -> vector_sink_c_sptr
        __init__(vector_sink_c_sptr self, vector_sink_c p) -> vector_sink_c_sptr
        """
        _blocks_swig1.vector_sink_c_sptr_swiginit(self, _blocks_swig1.new_vector_sink_c_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_sink< gr_complex > *":
        r"""__deref__(vector_sink_c_sptr self) -> vector_sink_c"""
        return _blocks_swig1.vector_sink_c_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_sink_c_sptr

    def make(self, vlen: "unsigned int const"=1, reserve_items: "int const"=1024) -> "gr::blocks::vector_sink< std::complex< float > >::sptr":
        r"""
        make(vector_sink_c_sptr self, unsigned int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr
        T sink that writes to a vector.

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_c_sptr_make(self, vlen, reserve_items)

    def reset(self) -> "void":
        r"""
        reset(vector_sink_c_sptr self)
        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_c_sptr_reset(self)

    def data(self) -> "std::vector< std::complex< float >,std::allocator< std::complex< float > > >":
        r"""data(vector_sink_c_sptr self) -> pmt_vector_cfloat"""
        return _blocks_swig1.vector_sink_c_sptr_data(self)

    def tags(self) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""tags(vector_sink_c_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_c_sptr_tags(self)

    def history(self) -> "unsigned int":
        r"""history(vector_sink_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_c_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_sink_c_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_sink_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_c_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_sink_c_sptr self, int multiple)"""
        return _blocks_swig1.vector_sink_c_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_sink_c_sptr self) -> double"""
        return _blocks_swig1.vector_sink_c_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_sink_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_sink_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_sink_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_sink_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_sink_c_sptr self, std::string level)"""
        return _blocks_swig1.vector_sink_c_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_sink_c_sptr self, int m)"""
        return _blocks_swig1.vector_sink_c_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_sink_c_sptr self)"""
        return _blocks_swig1.vector_sink_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_sink_c_sptr self, int m)"""
        return _blocks_swig1.vector_sink_c_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_sink_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_sink_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_sink_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_sink_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_sink_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_c_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_sink_c_sptr self)"""
        return _blocks_swig1.vector_sink_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_sink_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_c_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_sink_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_sink_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_sink_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_sink_c_sptr self) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_sink_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_sink_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_sink_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_c_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_sink_c_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_sink_c_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_sink_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_sink_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_sink_c_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_subscribers(self, which_port)

# Register vector_sink_c_sptr in _blocks_swig1:
_blocks_swig1.vector_sink_c_sptr_swigregister(vector_sink_c_sptr)


vector_sink_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_c = vector_sink_c.make

class vector_source_b(object):
    r"""
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(*args, **kwargs) -> "gr::blocks::vector_source< unsigned char >::sptr":
        r"""
        make(std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_b_make(*args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_b self)"""
        return _blocks_swig1.vector_source_b_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_b self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_b_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_b self, bool repeat)"""
        return _blocks_swig1.vector_source_b_set_repeat(self, repeat)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_b

# Register vector_source_b in _blocks_swig1:
_blocks_swig1.vector_source_b_swigregister(vector_source_b)

def vector_source_b_make(*args, **kwargs) -> "gr::blocks::vector_source< unsigned char >::sptr":
    r"""
    vector_source_b_make(std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    return _blocks_swig1.vector_source_b_make(*args, **kwargs)

class vector_source_b_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_source< std::uint8_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_source_b_sptr self) -> vector_source_b_sptr
        __init__(vector_source_b_sptr self, vector_source_b p) -> vector_source_b_sptr
        """
        _blocks_swig1.vector_source_b_sptr_swiginit(self, _blocks_swig1.new_vector_source_b_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_source< std::uint8_t > *":
        r"""__deref__(vector_source_b_sptr self) -> vector_source_b"""
        return _blocks_swig1.vector_source_b_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_b_sptr

    def make(self, *args, **kwargs) -> "gr::blocks::vector_source< unsigned char >::sptr":
        r"""
        make(vector_source_b_sptr self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_b_sptr_make(self, *args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_b_sptr self, std::vector< std::uint8_t,std::allocator< std::uint8_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_b_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_b_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_b_sptr_set_repeat(self, repeat)

    def history(self) -> "unsigned int":
        r"""history(vector_source_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_b_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_source_b_sptr self, int which, int delay)
        declare_sample_delay(vector_source_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_source_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_b_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_source_b_sptr self, int multiple)"""
        return _blocks_swig1.vector_source_b_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_source_b_sptr self) -> double"""
        return _blocks_swig1.vector_source_b_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_source_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_source_b_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_source_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_source_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_source_b_sptr self, std::string level)"""
        return _blocks_swig1.vector_source_b_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_source_b_sptr self, int m)"""
        return _blocks_swig1.vector_source_b_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_source_b_sptr self, int m)"""
        return _blocks_swig1.vector_source_b_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_source_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_b_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_source_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_source_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_b_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_source_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_source_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_b_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_source_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_b_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_source_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_b_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_source_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_b_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_source_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_b_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_source_b_sptr self) -> long"""
        return _blocks_swig1.vector_source_b_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_source_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_b_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_source_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_source_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_b_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_source_b_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_source_b_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_source_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_source_b_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_source_b_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_subscribers(self, which_port)

# Register vector_source_b_sptr in _blocks_swig1:
_blocks_swig1.vector_source_b_sptr_swigregister(vector_source_b_sptr)


vector_source_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_b = vector_source_b.make

class vector_source_s(object):
    r"""
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(*args, **kwargs) -> "gr::blocks::vector_source< short >::sptr":
        r"""
        make(std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_s_make(*args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_s self)"""
        return _blocks_swig1.vector_source_s_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_s self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_s_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_s self, bool repeat)"""
        return _blocks_swig1.vector_source_s_set_repeat(self, repeat)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_s

# Register vector_source_s in _blocks_swig1:
_blocks_swig1.vector_source_s_swigregister(vector_source_s)

def vector_source_s_make(*args, **kwargs) -> "gr::blocks::vector_source< short >::sptr":
    r"""
    vector_source_s_make(std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    return _blocks_swig1.vector_source_s_make(*args, **kwargs)

class vector_source_s_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_source< std::int16_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_source_s_sptr self) -> vector_source_s_sptr
        __init__(vector_source_s_sptr self, vector_source_s p) -> vector_source_s_sptr
        """
        _blocks_swig1.vector_source_s_sptr_swiginit(self, _blocks_swig1.new_vector_source_s_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_source< std::int16_t > *":
        r"""__deref__(vector_source_s_sptr self) -> vector_source_s"""
        return _blocks_swig1.vector_source_s_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_s_sptr

    def make(self, *args, **kwargs) -> "gr::blocks::vector_source< short >::sptr":
        r"""
        make(vector_source_s_sptr self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_s_sptr_make(self, *args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_s_sptr self, std::vector< std::int16_t,std::allocator< std::int16_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_s_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_s_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_s_sptr_set_repeat(self, repeat)

    def history(self) -> "unsigned int":
        r"""history(vector_source_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_s_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_source_s_sptr self, int which, int delay)
        declare_sample_delay(vector_source_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_source_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_s_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_source_s_sptr self, int multiple)"""
        return _blocks_swig1.vector_source_s_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_source_s_sptr self) -> double"""
        return _blocks_swig1.vector_source_s_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_source_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_source_s_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_source_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_source_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_source_s_sptr self, std::string level)"""
        return _blocks_swig1.vector_source_s_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_source_s_sptr self, int m)"""
        return _blocks_swig1.vector_source_s_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_source_s_sptr self, int m)"""
        return _blocks_swig1.vector_source_s_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_source_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_s_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_source_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_source_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_s_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_source_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_source_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_s_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_source_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_s_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_source_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_s_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_source_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_s_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_source_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_s_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_source_s_sptr self) -> long"""
        return _blocks_swig1.vector_source_s_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_source_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_s_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_source_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_source_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_s_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_source_s_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_source_s_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_source_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_source_s_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_source_s_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_subscribers(self, which_port)

# Register vector_source_s_sptr in _blocks_swig1:
_blocks_swig1.vector_source_s_sptr_swigregister(vector_source_s_sptr)


vector_source_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_s = vector_source_s.make

class vector_source_i(object):
    r"""
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(*args, **kwargs) -> "gr::blocks::vector_source< int >::sptr":
        r"""
        make(std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_i_make(*args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_i self)"""
        return _blocks_swig1.vector_source_i_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_i self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_i_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_i self, bool repeat)"""
        return _blocks_swig1.vector_source_i_set_repeat(self, repeat)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_i

# Register vector_source_i in _blocks_swig1:
_blocks_swig1.vector_source_i_swigregister(vector_source_i)

def vector_source_i_make(*args, **kwargs) -> "gr::blocks::vector_source< int >::sptr":
    r"""
    vector_source_i_make(std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    return _blocks_swig1.vector_source_i_make(*args, **kwargs)

class vector_source_i_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_source< std::int32_t > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_source_i_sptr self) -> vector_source_i_sptr
        __init__(vector_source_i_sptr self, vector_source_i p) -> vector_source_i_sptr
        """
        _blocks_swig1.vector_source_i_sptr_swiginit(self, _blocks_swig1.new_vector_source_i_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_source< std::int32_t > *":
        r"""__deref__(vector_source_i_sptr self) -> vector_source_i"""
        return _blocks_swig1.vector_source_i_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_i_sptr

    def make(self, *args, **kwargs) -> "gr::blocks::vector_source< int >::sptr":
        r"""
        make(vector_source_i_sptr self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_i_sptr_make(self, *args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_i_sptr self, std::vector< std::int32_t,std::allocator< std::int32_t > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_i_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_i_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_i_sptr_set_repeat(self, repeat)

    def history(self) -> "unsigned int":
        r"""history(vector_source_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_i_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_source_i_sptr self, int which, int delay)
        declare_sample_delay(vector_source_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_source_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_i_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_source_i_sptr self, int multiple)"""
        return _blocks_swig1.vector_source_i_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_source_i_sptr self) -> double"""
        return _blocks_swig1.vector_source_i_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_source_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_source_i_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_source_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_source_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_source_i_sptr self, std::string level)"""
        return _blocks_swig1.vector_source_i_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_source_i_sptr self, int m)"""
        return _blocks_swig1.vector_source_i_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_source_i_sptr self, int m)"""
        return _blocks_swig1.vector_source_i_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_source_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_i_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_source_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_source_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_i_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_source_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_source_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_i_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_source_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_i_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_source_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_i_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_source_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_i_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_source_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_i_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_source_i_sptr self) -> long"""
        return _blocks_swig1.vector_source_i_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_source_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_i_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_source_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_source_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_i_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_source_i_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_source_i_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_source_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_source_i_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_source_i_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_subscribers(self, which_port)

# Register vector_source_i_sptr in _blocks_swig1:
_blocks_swig1.vector_source_i_sptr_swigregister(vector_source_i_sptr)


vector_source_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_i = vector_source_i.make

class vector_source_f(object):
    r"""
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(*args, **kwargs) -> "gr::blocks::vector_source< float >::sptr":
        r"""
        make(pmt_vector_float data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_f_make(*args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_f self)"""
        return _blocks_swig1.vector_source_f_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_f self, pmt_vector_float data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_f_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_f self, bool repeat)"""
        return _blocks_swig1.vector_source_f_set_repeat(self, repeat)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_f

# Register vector_source_f in _blocks_swig1:
_blocks_swig1.vector_source_f_swigregister(vector_source_f)

def vector_source_f_make(*args, **kwargs) -> "gr::blocks::vector_source< float >::sptr":
    r"""
    vector_source_f_make(pmt_vector_float data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    return _blocks_swig1.vector_source_f_make(*args, **kwargs)

class vector_source_f_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_source< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_source_f_sptr self) -> vector_source_f_sptr
        __init__(vector_source_f_sptr self, vector_source_f p) -> vector_source_f_sptr
        """
        _blocks_swig1.vector_source_f_sptr_swiginit(self, _blocks_swig1.new_vector_source_f_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_source< float > *":
        r"""__deref__(vector_source_f_sptr self) -> vector_source_f"""
        return _blocks_swig1.vector_source_f_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_f_sptr

    def make(self, *args, **kwargs) -> "gr::blocks::vector_source< float >::sptr":
        r"""
        make(vector_source_f_sptr self, pmt_vector_float data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_f_sptr_make(self, *args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_f_sptr self, pmt_vector_float data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_f_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_f_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_f_sptr_set_repeat(self, repeat)

    def history(self) -> "unsigned int":
        r"""history(vector_source_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_f_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_source_f_sptr self, int which, int delay)
        declare_sample_delay(vector_source_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_source_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_f_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_source_f_sptr self, int multiple)"""
        return _blocks_swig1.vector_source_f_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_source_f_sptr self) -> double"""
        return _blocks_swig1.vector_source_f_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_source_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_source_f_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_source_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_source_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_source_f_sptr self, std::string level)"""
        return _blocks_swig1.vector_source_f_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_source_f_sptr self, int m)"""
        return _blocks_swig1.vector_source_f_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_source_f_sptr self, int m)"""
        return _blocks_swig1.vector_source_f_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_source_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_f_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_source_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_source_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_f_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_source_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_source_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_f_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_source_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_f_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_source_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_f_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_source_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_f_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_source_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_f_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_source_f_sptr self) -> long"""
        return _blocks_swig1.vector_source_f_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_source_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_f_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_source_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_source_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_f_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_source_f_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_source_f_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_source_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_source_f_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_source_f_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_subscribers(self, which_port)

# Register vector_source_f_sptr in _blocks_swig1:
_blocks_swig1.vector_source_f_sptr_swigregister(vector_source_f_sptr)


vector_source_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_f = vector_source_f.make

class vector_source_c(object):
    r"""
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(*args, **kwargs) -> "gr::blocks::vector_source< std::complex< float > >::sptr":
        r"""
        make(pmt_vector_cfloat data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_c_make(*args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_c self)"""
        return _blocks_swig1.vector_source_c_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_c self, pmt_vector_cfloat data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_c_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_c self, bool repeat)"""
        return _blocks_swig1.vector_source_c_set_repeat(self, repeat)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_c

# Register vector_source_c in _blocks_swig1:
_blocks_swig1.vector_source_c_swigregister(vector_source_c)

def vector_source_c_make(*args, **kwargs) -> "gr::blocks::vector_source< std::complex< float > >::sptr":
    r"""
    vector_source_c_make(pmt_vector_cfloat data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr
    Source that streams T items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    return _blocks_swig1.vector_source_c_make(*args, **kwargs)

class vector_source_c_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::vector_source< gr_complex > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(vector_source_c_sptr self) -> vector_source_c_sptr
        __init__(vector_source_c_sptr self, vector_source_c p) -> vector_source_c_sptr
        """
        _blocks_swig1.vector_source_c_sptr_swiginit(self, _blocks_swig1.new_vector_source_c_sptr(*args))

    def __deref__(self) -> "gr::blocks::vector_source< gr_complex > *":
        r"""__deref__(vector_source_c_sptr self) -> vector_source_c"""
        return _blocks_swig1.vector_source_c_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_vector_source_c_sptr

    def make(self, *args, **kwargs) -> "gr::blocks::vector_source< std::complex< float > >::sptr":
        r"""
        make(vector_source_c_sptr self, pmt_vector_cfloat data, bool repeat=False, unsigned int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr
        Source that streams T items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<T>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.


        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.


        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.


        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.


        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_c_sptr_make(self, *args, **kwargs)

    def rewind(self) -> "void":
        r"""rewind(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_rewind(self)

    def set_data(self, *args, **kwargs) -> "void":
        r"""set_data(vector_source_c_sptr self, pmt_vector_cfloat data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_c_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, repeat: "bool") -> "void":
        r"""set_repeat(vector_source_c_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_c_sptr_set_repeat(self, repeat)

    def history(self) -> "unsigned int":
        r"""history(vector_source_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_c_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(vector_source_c_sptr self, int which, int delay)
        declare_sample_delay(vector_source_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(vector_source_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_c_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(vector_source_c_sptr self, int multiple)"""
        return _blocks_swig1.vector_source_c_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(vector_source_c_sptr self) -> double"""
        return _blocks_swig1.vector_source_c_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(vector_source_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(vector_source_c_sptr self) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(vector_source_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(vector_source_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(vector_source_c_sptr self, std::string level)"""
        return _blocks_swig1.vector_source_c_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(vector_source_c_sptr self, int m)"""
        return _blocks_swig1.vector_source_c_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(vector_source_c_sptr self, int m)"""
        return _blocks_swig1.vector_source_c_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(vector_source_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_c_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(vector_source_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(vector_source_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_c_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(vector_source_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(vector_source_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_c_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(vector_source_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_c_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(vector_source_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_c_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(vector_source_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_c_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(vector_source_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_c_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(vector_source_c_sptr self) -> long"""
        return _blocks_swig1.vector_source_c_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(vector_source_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_c_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(vector_source_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(vector_source_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_c_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(vector_source_c_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.vector_source_c_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(vector_source_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(vector_source_c_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(vector_source_c_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_subscribers(self, which_port)

# Register vector_source_c_sptr in _blocks_swig1:
_blocks_swig1.vector_source_c_sptr_swigregister(vector_source_c_sptr)


vector_source_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_c = vector_source_c.make

class wavfile_sink_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::wavfile_sink > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(wavfile_sink_sptr self) -> wavfile_sink_sptr
        __init__(wavfile_sink_sptr self, wavfile_sink p) -> wavfile_sink_sptr
        """
        _blocks_swig1.wavfile_sink_sptr_swiginit(self, _blocks_swig1.new_wavfile_sink_sptr(*args))

    def __deref__(self) -> "gr::blocks::wavfile_sink *":
        r"""__deref__(wavfile_sink_sptr self) -> wavfile_sink"""
        return _blocks_swig1.wavfile_sink_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_wavfile_sink_sptr

    def make(self, filename: "char const *", n_channels: "int", sample_rate: "unsigned int", bits_per_sample: "int"=16) -> "gr::blocks::wavfile_sink::sptr":
        r"""
        make(wavfile_sink_sptr self, char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr
        Write stream to a Microsoft PCM (.wav) file.

        Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            n_channels : 
            sample_rate : 
            bits_per_sample : 
        """
        return _blocks_swig1.wavfile_sink_sptr_make(self, filename, n_channels, sample_rate, bits_per_sample)

    def open(self, filename: "char const *") -> "bool":
        r"""
        open(wavfile_sink_sptr self, char const * filename) -> bool
        Opens a new file and writes a WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_sptr_open(self, filename)

    def close(self) -> "void":
        r"""
        close(wavfile_sink_sptr self)
        Closes the currently active file and completes the WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_sptr_close(self)

    def set_sample_rate(self, sample_rate: "unsigned int") -> "void":
        r"""
        set_sample_rate(wavfile_sink_sptr self, unsigned int sample_rate)
        Set the sample rate. This will not affect the WAV file currently opened. Any following open() calls will use this new sample rate.
        """
        return _blocks_swig1.wavfile_sink_sptr_set_sample_rate(self, sample_rate)

    def set_bits_per_sample(self, bits_per_sample: "int") -> "void":
        r"""
        set_bits_per_sample(wavfile_sink_sptr self, int bits_per_sample)
        Set bits per sample. This will not affect the WAV file currently opened (see set_sample_rate()). If the value is neither 8 nor 16, the call is ignored and the current value is kept.
        """
        return _blocks_swig1.wavfile_sink_sptr_set_bits_per_sample(self, bits_per_sample)

    def history(self) -> "unsigned int":
        r"""history(wavfile_sink_sptr self) -> unsigned int"""
        return _blocks_swig1.wavfile_sink_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(wavfile_sink_sptr self, int which, int delay)
        declare_sample_delay(wavfile_sink_sptr self, unsigned int delay)
        """
        return _blocks_swig1.wavfile_sink_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(wavfile_sink_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.wavfile_sink_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(wavfile_sink_sptr self, int multiple)"""
        return _blocks_swig1.wavfile_sink_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(wavfile_sink_sptr self) -> double"""
        return _blocks_swig1.wavfile_sink_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(wavfile_sink_sptr self) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(wavfile_sink_sptr self) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(wavfile_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(wavfile_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(wavfile_sink_sptr self, std::string level)"""
        return _blocks_swig1.wavfile_sink_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(wavfile_sink_sptr self, int m)"""
        return _blocks_swig1.wavfile_sink_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(wavfile_sink_sptr self)"""
        return _blocks_swig1.wavfile_sink_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(wavfile_sink_sptr self, int m)"""
        return _blocks_swig1.wavfile_sink_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(wavfile_sink_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(wavfile_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(wavfile_sink_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.wavfile_sink_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(wavfile_sink_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(wavfile_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(wavfile_sink_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.wavfile_sink_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(wavfile_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.wavfile_sink_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(wavfile_sink_sptr self)"""
        return _blocks_swig1.wavfile_sink_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(wavfile_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.wavfile_sink_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(wavfile_sink_sptr self, int priority) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(wavfile_sink_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(wavfile_sink_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(wavfile_sink_sptr self) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(wavfile_sink_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(wavfile_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(wavfile_sink_sptr self, std::string name)"""
        return _blocks_swig1.wavfile_sink_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(wavfile_sink_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.wavfile_sink_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(wavfile_sink_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(wavfile_sink_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(wavfile_sink_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_subscribers(self, which_port)

# Register wavfile_sink_sptr in _blocks_swig1:
_blocks_swig1.wavfile_sink_sptr_swigregister(wavfile_sink_sptr)


wavfile_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
wavfile_sink = wavfile_sink.make;

class wavfile_source_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::blocks::wavfile_source > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(wavfile_source_sptr self) -> wavfile_source_sptr
        __init__(wavfile_source_sptr self, wavfile_source p) -> wavfile_source_sptr
        """
        _blocks_swig1.wavfile_source_sptr_swiginit(self, _blocks_swig1.new_wavfile_source_sptr(*args))

    def __deref__(self) -> "gr::blocks::wavfile_source *":
        r"""__deref__(wavfile_source_sptr self) -> wavfile_source"""
        return _blocks_swig1.wavfile_source_sptr___deref__(self)
    __swig_destroy__ = _blocks_swig1.delete_wavfile_source_sptr

    def make(self, filename: "char const *", repeat: "bool"=False) -> "gr::blocks::wavfile_source::sptr":
        r"""
        make(wavfile_source_sptr self, char const * filename, bool repeat=False) -> wavfile_source_sptr
        Read stream from a Microsoft PCM (.wav) file, output floats.

        Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            repeat : 
        """
        return _blocks_swig1.wavfile_source_sptr_make(self, filename, repeat)

    def sample_rate(self) -> "unsigned int":
        r"""
        sample_rate(wavfile_source_sptr self) -> unsigned int
        Read the sample rate as specified in the wav file header.
        """
        return _blocks_swig1.wavfile_source_sptr_sample_rate(self)

    def bits_per_sample(self) -> "int":
        r"""
        bits_per_sample(wavfile_source_sptr self) -> int
        Return the number of bits per sample as specified in the wav file header. Only 8 or 16 bit are supported here.
        """
        return _blocks_swig1.wavfile_source_sptr_bits_per_sample(self)

    def channels(self) -> "int":
        r"""
        channels(wavfile_source_sptr self) -> int
        Return the number of channels in the wav file as specified in the wav file header. This is also the max number of outputs you can have.
        """
        return _blocks_swig1.wavfile_source_sptr_channels(self)

    def history(self) -> "unsigned int":
        r"""history(wavfile_source_sptr self) -> unsigned int"""
        return _blocks_swig1.wavfile_source_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(wavfile_source_sptr self, int which, int delay)
        declare_sample_delay(wavfile_source_sptr self, unsigned int delay)
        """
        return _blocks_swig1.wavfile_source_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""sample_delay(wavfile_source_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.wavfile_source_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""set_output_multiple(wavfile_source_sptr self, int multiple)"""
        return _blocks_swig1.wavfile_source_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""relative_rate(wavfile_source_sptr self) -> double"""
        return _blocks_swig1.wavfile_source_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""relative_rate_i(wavfile_source_sptr self) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""relative_rate_d(wavfile_source_sptr self) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""start(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_start(self)

    def stop(self) -> "bool":
        r"""stop(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""nitems_read(wavfile_source_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""nitems_written(wavfile_source_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""set_log_level(wavfile_source_sptr self, std::string level)"""
        return _blocks_swig1.wavfile_source_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""log_level(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""max_noutput_items(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""set_max_noutput_items(wavfile_source_sptr self, int m)"""
        return _blocks_swig1.wavfile_source_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""unset_max_noutput_items(wavfile_source_sptr self)"""
        return _blocks_swig1.wavfile_source_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""is_set_max_noutput_items(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""set_min_noutput_items(wavfile_source_sptr self, int m)"""
        return _blocks_swig1.wavfile_source_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""min_noutput_items(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""max_output_buffer(wavfile_source_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_source_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(wavfile_source_sptr self, long max_output_buffer)
        set_max_output_buffer(wavfile_source_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.wavfile_source_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""min_output_buffer(wavfile_source_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_source_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(wavfile_source_sptr self, long min_output_buffer)
        set_min_output_buffer(wavfile_source_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.wavfile_source_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""pc_noutput_items(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""pc_noutput_items_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""pc_noutput_items_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""pc_nproduced(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""pc_nproduced_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""pc_nproduced_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full_avg(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full_var(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full_avg(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full_var(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""pc_work_time(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""pc_work_time_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""pc_work_time_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""pc_work_time_total(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""pc_throughput_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""set_processor_affinity(wavfile_source_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.wavfile_source_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""unset_processor_affinity(wavfile_source_sptr self)"""
        return _blocks_swig1.wavfile_source_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""processor_affinity(wavfile_source_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.wavfile_source_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""active_thread_priority(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""thread_priority(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""set_thread_priority(wavfile_source_sptr self, int priority) -> int"""
        return _blocks_swig1.wavfile_source_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""name(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""symbol_name(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(wavfile_source_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_source_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(wavfile_source_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_source_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(wavfile_source_sptr self) -> long"""
        return _blocks_swig1.wavfile_source_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(wavfile_source_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.wavfile_source_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""check_topology(wavfile_source_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""alias(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""set_block_alias(wavfile_source_sptr self, std::string name)"""
        return _blocks_swig1.wavfile_source_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""_post(wavfile_source_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)"""
        return _blocks_swig1.wavfile_source_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""message_ports_in(wavfile_source_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""message_ports_out(wavfile_source_sptr self) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(wavfile_source_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_subscribers(self, which_port)

# Register wavfile_source_sptr in _blocks_swig1:
_blocks_swig1.wavfile_source_sptr_swigregister(wavfile_source_sptr)


wavfile_source_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
wavfile_source = wavfile_source.make;



