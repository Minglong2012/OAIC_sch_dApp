# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _runtime_swig
else:
    import _runtime_swig

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _runtime_swig.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool
        pmt::equal recursively compares the contents of pairs and vectors, applying pmt::eqv on other objects such as numbers and symbols. pmt::equal may fail to terminate if its arguments are circular data structures.
        """
        return _runtime_swig.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _runtime_swig.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _runtime_swig.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _runtime_swig.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _runtime_swig:
_runtime_swig.SwigPyIterator_swigregister(SwigPyIterator)

class gr_vsize_t(object):
    r"""Proxy of C++ std::vector< size_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vsize_t self) -> SwigPyIterator"""
        return _runtime_swig.gr_vsize_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t___bool__(self)

    def __len__(self) -> "std::vector< size_t >::size_type":
        r"""__len__(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t___len__(self)

    def __getslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "std::vector< size_t,std::allocator< size_t > > *":
        r"""__getslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j) -> gr_vsize_t"""
        return _runtime_swig.gr_vsize_t___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j)
        __setslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j, gr_vsize_t v)
        """
        return _runtime_swig.gr_vsize_t___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "void":
        r"""__delslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j)"""
        return _runtime_swig.gr_vsize_t___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vsize_t self, std::vector< size_t >::difference_type i)
        __delitem__(gr_vsize_t self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vsize_t___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< size_t >::value_type const &":
        r"""
        __getitem__(gr_vsize_t self, PySliceObject * slice) -> gr_vsize_t
        __getitem__(gr_vsize_t self, std::vector< size_t >::difference_type i) -> std::vector< size_t >::value_type const &
        """
        return _runtime_swig.gr_vsize_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vsize_t self, PySliceObject * slice, gr_vsize_t v)
        __setitem__(gr_vsize_t self, PySliceObject * slice)
        __setitem__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t___setitem__(self, *args)

    def pop(self) -> "std::vector< size_t >::value_type":
        r"""pop(gr_vsize_t self) -> std::vector< size_t >::value_type"""
        return _runtime_swig.gr_vsize_t_pop(self)

    def append(self, x: "std::vector< size_t >::value_type const &") -> "void":
        r"""append(gr_vsize_t self, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t_empty(self)

    def size(self) -> "std::vector< size_t >::size_type":
        r"""size(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t_size(self)

    def swap(self, v: "gr_vsize_t") -> "void":
        r"""swap(gr_vsize_t self, gr_vsize_t v)"""
        return _runtime_swig.gr_vsize_t_swap(self, v)

    def begin(self) -> "std::vector< size_t >::iterator":
        r"""begin(gr_vsize_t self) -> std::vector< size_t >::iterator"""
        return _runtime_swig.gr_vsize_t_begin(self)

    def end(self) -> "std::vector< size_t >::iterator":
        r"""end(gr_vsize_t self) -> std::vector< size_t >::iterator"""
        return _runtime_swig.gr_vsize_t_end(self)

    def rbegin(self) -> "std::vector< size_t >::reverse_iterator":
        r"""rbegin(gr_vsize_t self) -> std::vector< size_t >::reverse_iterator"""
        return _runtime_swig.gr_vsize_t_rbegin(self)

    def rend(self) -> "std::vector< size_t >::reverse_iterator":
        r"""rend(gr_vsize_t self) -> std::vector< size_t >::reverse_iterator"""
        return _runtime_swig.gr_vsize_t_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vsize_t self)"""
        return _runtime_swig.gr_vsize_t_clear(self)

    def get_allocator(self) -> "std::vector< size_t >::allocator_type":
        r"""get_allocator(gr_vsize_t self) -> std::vector< size_t >::allocator_type"""
        return _runtime_swig.gr_vsize_t_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vsize_t self)"""
        return _runtime_swig.gr_vsize_t_pop_back(self)

    def erase(self, *args) -> "std::vector< size_t >::iterator":
        r"""
        erase(gr_vsize_t self, std::vector< size_t >::iterator pos) -> std::vector< size_t >::iterator
        erase(gr_vsize_t self, std::vector< size_t >::iterator first, std::vector< size_t >::iterator last) -> std::vector< size_t >::iterator
        """
        return _runtime_swig.gr_vsize_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vsize_t self) -> gr_vsize_t
        __init__(gr_vsize_t self, gr_vsize_t other) -> gr_vsize_t
        __init__(gr_vsize_t self, std::vector< size_t >::size_type size) -> gr_vsize_t
        __init__(gr_vsize_t self, std::vector< size_t >::size_type size, std::vector< size_t >::value_type const & value) -> gr_vsize_t
        """
        _runtime_swig.gr_vsize_t_swiginit(self, _runtime_swig.new_gr_vsize_t(*args))

    def push_back(self, x: "std::vector< size_t >::value_type const &") -> "void":
        r"""push_back(gr_vsize_t self, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_push_back(self, x)

    def front(self) -> "std::vector< size_t >::value_type const &":
        r"""front(gr_vsize_t self) -> std::vector< size_t >::value_type const &"""
        return _runtime_swig.gr_vsize_t_front(self)

    def back(self) -> "std::vector< size_t >::value_type const &":
        r"""back(gr_vsize_t self) -> std::vector< size_t >::value_type const &"""
        return _runtime_swig.gr_vsize_t_back(self)

    def assign(self, n: "std::vector< size_t >::size_type", x: "std::vector< size_t >::value_type const &") -> "void":
        r"""assign(gr_vsize_t self, std::vector< size_t >::size_type n, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vsize_t self, std::vector< size_t >::size_type new_size)
        resize(gr_vsize_t self, std::vector< size_t >::size_type new_size, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vsize_t self, std::vector< size_t >::iterator pos, std::vector< size_t >::value_type const & x) -> std::vector< size_t >::iterator
        insert(gr_vsize_t self, std::vector< size_t >::iterator pos, std::vector< size_t >::size_type n, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t_insert(self, *args)

    def reserve(self, n: "std::vector< size_t >::size_type") -> "void":
        r"""reserve(gr_vsize_t self, std::vector< size_t >::size_type n)"""
        return _runtime_swig.gr_vsize_t_reserve(self, n)

    def capacity(self) -> "std::vector< size_t >::size_type":
        r"""capacity(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vsize_t

# Register gr_vsize_t in _runtime_swig:
_runtime_swig.gr_vsize_t_swigregister(gr_vsize_t)

class gr_vvvsize_t(object):
    r"""Proxy of C++ std::vector< std::vector< std::vector< size_t > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vvvsize_t self) -> SwigPyIterator"""
        return _runtime_swig.gr_vvvsize_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t___bool__(self)

    def __len__(self) -> "std::vector< std::vector< std::vector< size_t > > >::size_type":
        r"""__len__(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< std::vector< size_t > > >::difference_type", j: "std::vector< std::vector< std::vector< size_t > > >::difference_type") -> "std::vector< std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > >,std::allocator< std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > > > > *":
        r"""__getslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j) -> gr_vvvsize_t"""
        return _runtime_swig.gr_vvvsize_t___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j)
        __setslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j, gr_vvvsize_t v)
        """
        return _runtime_swig.gr_vvvsize_t___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< std::vector< size_t > > >::difference_type", j: "std::vector< std::vector< std::vector< size_t > > >::difference_type") -> "void":
        r"""__delslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j)"""
        return _runtime_swig.gr_vvvsize_t___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i)
        __delitem__(gr_vvvsize_t self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vvvsize_t___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< std::vector< size_t > > >::value_type const &":
        r"""
        __getitem__(gr_vvvsize_t self, PySliceObject * slice) -> gr_vvvsize_t
        __getitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &
        """
        return _runtime_swig.gr_vvvsize_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vvvsize_t self, PySliceObject * slice, gr_vvvsize_t v)
        __setitem__(gr_vvvsize_t self, PySliceObject * slice)
        __setitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< std::vector< size_t > > >::value_type":
        r"""pop(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type"""
        return _runtime_swig.gr_vvvsize_t_pop(self)

    def append(self, x: "std::vector< std::vector< std::vector< size_t > > >::value_type const &") -> "void":
        r"""append(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t_empty(self)

    def size(self) -> "std::vector< std::vector< std::vector< size_t > > >::size_type":
        r"""size(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t_size(self)

    def swap(self, v: "gr_vvvsize_t") -> "void":
        r"""swap(gr_vvvsize_t self, gr_vvvsize_t v)"""
        return _runtime_swig.gr_vvvsize_t_swap(self, v)

    def begin(self) -> "std::vector< std::vector< std::vector< size_t > > >::iterator":
        r"""begin(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::iterator"""
        return _runtime_swig.gr_vvvsize_t_begin(self)

    def end(self) -> "std::vector< std::vector< std::vector< size_t > > >::iterator":
        r"""end(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::iterator"""
        return _runtime_swig.gr_vvvsize_t_end(self)

    def rbegin(self) -> "std::vector< std::vector< std::vector< size_t > > >::reverse_iterator":
        r"""rbegin(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::reverse_iterator"""
        return _runtime_swig.gr_vvvsize_t_rbegin(self)

    def rend(self) -> "std::vector< std::vector< std::vector< size_t > > >::reverse_iterator":
        r"""rend(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::reverse_iterator"""
        return _runtime_swig.gr_vvvsize_t_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vvvsize_t self)"""
        return _runtime_swig.gr_vvvsize_t_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< std::vector< size_t > > >::allocator_type":
        r"""get_allocator(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::allocator_type"""
        return _runtime_swig.gr_vvvsize_t_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vvvsize_t self)"""
        return _runtime_swig.gr_vvvsize_t_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< std::vector< size_t > > >::iterator":
        r"""
        erase(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        erase(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator first, std::vector< std::vector< std::vector< size_t > > >::iterator last) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        """
        return _runtime_swig.gr_vvvsize_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vvvsize_t self) -> gr_vvvsize_t
        __init__(gr_vvvsize_t self, gr_vvvsize_t other) -> gr_vvvsize_t
        __init__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type size) -> gr_vvvsize_t
        __init__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type size, std::vector< std::vector< std::vector< size_t > > >::value_type const & value) -> gr_vvvsize_t
        """
        _runtime_swig.gr_vvvsize_t_swiginit(self, _runtime_swig.new_gr_vvvsize_t(*args))

    def push_back(self, x: "std::vector< std::vector< std::vector< size_t > > >::value_type const &") -> "void":
        r"""push_back(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_push_back(self, x)

    def front(self) -> "std::vector< std::vector< std::vector< size_t > > >::value_type const &":
        r"""front(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &"""
        return _runtime_swig.gr_vvvsize_t_front(self)

    def back(self) -> "std::vector< std::vector< std::vector< size_t > > >::value_type const &":
        r"""back(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &"""
        return _runtime_swig.gr_vvvsize_t_back(self)

    def assign(self, n: "std::vector< std::vector< std::vector< size_t > > >::size_type", x: "std::vector< std::vector< std::vector< size_t > > >::value_type const &") -> "void":
        r"""assign(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type n, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type new_size)
        resize(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type new_size, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos, std::vector< std::vector< std::vector< size_t > > >::value_type const & x) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        insert(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos, std::vector< std::vector< std::vector< size_t > > >::size_type n, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< std::vector< size_t > > >::size_type") -> "void":
        r"""reserve(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type n)"""
        return _runtime_swig.gr_vvvsize_t_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< std::vector< size_t > > >::size_type":
        r"""capacity(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vvvsize_t

# Register gr_vvvsize_t in _runtime_swig:
_runtime_swig.gr_vvvsize_t_swigregister(gr_vvvsize_t)

class gr_vector_complexf(object):
    r"""Proxy of C++ std::vector< std::complex< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vector_complexf self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_complexf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf___bool__(self)

    def __len__(self) -> "std::vector< std::complex< float > >::size_type":
        r"""__len__(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf___len__(self)

    def __getslice__(self, i: "std::vector< std::complex< float > >::difference_type", j: "std::vector< std::complex< float > >::difference_type") -> "std::vector< std::complex< float >,std::allocator< std::complex< float > > > *":
        r"""__getslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > > *"""
        return _runtime_swig.gr_vector_complexf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j)
        __setslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j, std::vector< std::complex< float >,std::allocator< std::complex< float > > > const & v)
        """
        return _runtime_swig.gr_vector_complexf___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::complex< float > >::difference_type", j: "std::vector< std::complex< float > >::difference_type") -> "void":
        r"""__delslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j)"""
        return _runtime_swig.gr_vector_complexf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i)
        __delitem__(gr_vector_complexf self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_complexf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::complex< float > >::value_type const &":
        r"""
        __getitem__(gr_vector_complexf self, PySliceObject * slice) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > >
        __getitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i) -> std::vector< std::complex< float > >::value_type const &
        """
        return _runtime_swig.gr_vector_complexf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vector_complexf self, PySliceObject * slice, std::vector< std::complex< float >,std::allocator< std::complex< float > > > const & v)
        __setitem__(gr_vector_complexf self, PySliceObject * slice)
        __setitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf___setitem__(self, *args)

    def pop(self) -> "std::vector< std::complex< float > >::value_type":
        r"""pop(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type"""
        return _runtime_swig.gr_vector_complexf_pop(self)

    def append(self, x: "std::vector< std::complex< float > >::value_type const &") -> "void":
        r"""append(gr_vector_complexf self, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf_empty(self)

    def size(self) -> "std::vector< std::complex< float > >::size_type":
        r"""size(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf_size(self)

    def swap(self, v: "gr_vector_complexf") -> "void":
        r"""swap(gr_vector_complexf self, gr_vector_complexf v)"""
        return _runtime_swig.gr_vector_complexf_swap(self, v)

    def begin(self) -> "std::vector< std::complex< float > >::iterator":
        r"""begin(gr_vector_complexf self) -> std::vector< std::complex< float > >::iterator"""
        return _runtime_swig.gr_vector_complexf_begin(self)

    def end(self) -> "std::vector< std::complex< float > >::iterator":
        r"""end(gr_vector_complexf self) -> std::vector< std::complex< float > >::iterator"""
        return _runtime_swig.gr_vector_complexf_end(self)

    def rbegin(self) -> "std::vector< std::complex< float > >::reverse_iterator":
        r"""rbegin(gr_vector_complexf self) -> std::vector< std::complex< float > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexf_rbegin(self)

    def rend(self) -> "std::vector< std::complex< float > >::reverse_iterator":
        r"""rend(gr_vector_complexf self) -> std::vector< std::complex< float > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexf_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vector_complexf self)"""
        return _runtime_swig.gr_vector_complexf_clear(self)

    def get_allocator(self) -> "std::vector< std::complex< float > >::allocator_type":
        r"""get_allocator(gr_vector_complexf self) -> std::vector< std::complex< float > >::allocator_type"""
        return _runtime_swig.gr_vector_complexf_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vector_complexf self)"""
        return _runtime_swig.gr_vector_complexf_pop_back(self)

    def erase(self, *args) -> "std::vector< std::complex< float > >::iterator":
        r"""
        erase(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos) -> std::vector< std::complex< float > >::iterator
        erase(gr_vector_complexf self, std::vector< std::complex< float > >::iterator first, std::vector< std::complex< float > >::iterator last) -> std::vector< std::complex< float > >::iterator
        """
        return _runtime_swig.gr_vector_complexf_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vector_complexf self) -> gr_vector_complexf
        __init__(gr_vector_complexf self, gr_vector_complexf other) -> gr_vector_complexf
        __init__(gr_vector_complexf self, std::vector< std::complex< float > >::size_type size) -> gr_vector_complexf
        __init__(gr_vector_complexf self, std::vector< std::complex< float > >::size_type size, std::vector< std::complex< float > >::value_type const & value) -> gr_vector_complexf
        """
        _runtime_swig.gr_vector_complexf_swiginit(self, _runtime_swig.new_gr_vector_complexf(*args))

    def push_back(self, x: "std::vector< std::complex< float > >::value_type const &") -> "void":
        r"""push_back(gr_vector_complexf self, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_push_back(self, x)

    def front(self) -> "std::vector< std::complex< float > >::value_type const &":
        r"""front(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type const &"""
        return _runtime_swig.gr_vector_complexf_front(self)

    def back(self) -> "std::vector< std::complex< float > >::value_type const &":
        r"""back(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type const &"""
        return _runtime_swig.gr_vector_complexf_back(self)

    def assign(self, n: "std::vector< std::complex< float > >::size_type", x: "std::vector< std::complex< float > >::value_type const &") -> "void":
        r"""assign(gr_vector_complexf self, std::vector< std::complex< float > >::size_type n, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vector_complexf self, std::vector< std::complex< float > >::size_type new_size)
        resize(gr_vector_complexf self, std::vector< std::complex< float > >::size_type new_size, std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos, std::vector< std::complex< float > >::value_type const & x) -> std::vector< std::complex< float > >::iterator
        insert(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos, std::vector< std::complex< float > >::size_type n, std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf_insert(self, *args)

    def reserve(self, n: "std::vector< std::complex< float > >::size_type") -> "void":
        r"""reserve(gr_vector_complexf self, std::vector< std::complex< float > >::size_type n)"""
        return _runtime_swig.gr_vector_complexf_reserve(self, n)

    def capacity(self) -> "std::vector< std::complex< float > >::size_type":
        r"""capacity(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vector_complexf

# Register gr_vector_complexf in _runtime_swig:
_runtime_swig.gr_vector_complexf_swigregister(gr_vector_complexf)

class gr_vector_complexd(object):
    r"""Proxy of C++ std::vector< std::complex< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vector_complexd self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_complexd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd___bool__(self)

    def __len__(self) -> "std::vector< std::complex< double > >::size_type":
        r"""__len__(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd___len__(self)

    def __getslice__(self, i: "std::vector< std::complex< double > >::difference_type", j: "std::vector< std::complex< double > >::difference_type") -> "std::vector< std::complex< double >,std::allocator< std::complex< double > > > *":
        r"""__getslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_complexd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, gr_vector_complexd v)
        """
        return _runtime_swig.gr_vector_complexd___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::complex< double > >::difference_type", j: "std::vector< std::complex< double > >::difference_type") -> "void":
        r"""__delslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _runtime_swig.gr_vector_complexd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(gr_vector_complexd self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_complexd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::complex< double > >::value_type const &":
        r"""
        __getitem__(gr_vector_complexd self, PySliceObject * slice) -> gr_vector_complexd
        __getitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _runtime_swig.gr_vector_complexd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vector_complexd self, PySliceObject * slice, gr_vector_complexd v)
        __setitem__(gr_vector_complexd self, PySliceObject * slice)
        __setitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd___setitem__(self, *args)

    def pop(self) -> "std::vector< std::complex< double > >::value_type":
        r"""pop(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type"""
        return _runtime_swig.gr_vector_complexd_pop(self)

    def append(self, x: "std::vector< std::complex< double > >::value_type const &") -> "void":
        r"""append(gr_vector_complexd self, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd_empty(self)

    def size(self) -> "std::vector< std::complex< double > >::size_type":
        r"""size(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd_size(self)

    def swap(self, v: "gr_vector_complexd") -> "void":
        r"""swap(gr_vector_complexd self, gr_vector_complexd v)"""
        return _runtime_swig.gr_vector_complexd_swap(self, v)

    def begin(self) -> "std::vector< std::complex< double > >::iterator":
        r"""begin(gr_vector_complexd self) -> std::vector< std::complex< double > >::iterator"""
        return _runtime_swig.gr_vector_complexd_begin(self)

    def end(self) -> "std::vector< std::complex< double > >::iterator":
        r"""end(gr_vector_complexd self) -> std::vector< std::complex< double > >::iterator"""
        return _runtime_swig.gr_vector_complexd_end(self)

    def rbegin(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        r"""rbegin(gr_vector_complexd self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexd_rbegin(self)

    def rend(self) -> "std::vector< std::complex< double > >::reverse_iterator":
        r"""rend(gr_vector_complexd self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexd_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vector_complexd self)"""
        return _runtime_swig.gr_vector_complexd_clear(self)

    def get_allocator(self) -> "std::vector< std::complex< double > >::allocator_type":
        r"""get_allocator(gr_vector_complexd self) -> std::vector< std::complex< double > >::allocator_type"""
        return _runtime_swig.gr_vector_complexd_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vector_complexd self)"""
        return _runtime_swig.gr_vector_complexd_pop_back(self)

    def erase(self, *args) -> "std::vector< std::complex< double > >::iterator":
        r"""
        erase(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(gr_vector_complexd self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _runtime_swig.gr_vector_complexd_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vector_complexd self) -> gr_vector_complexd
        __init__(gr_vector_complexd self, gr_vector_complexd other) -> gr_vector_complexd
        __init__(gr_vector_complexd self, std::vector< std::complex< double > >::size_type size) -> gr_vector_complexd
        __init__(gr_vector_complexd self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> gr_vector_complexd
        """
        _runtime_swig.gr_vector_complexd_swiginit(self, _runtime_swig.new_gr_vector_complexd(*args))

    def push_back(self, x: "std::vector< std::complex< double > >::value_type const &") -> "void":
        r"""push_back(gr_vector_complexd self, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_push_back(self, x)

    def front(self) -> "std::vector< std::complex< double > >::value_type const &":
        r"""front(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type const &"""
        return _runtime_swig.gr_vector_complexd_front(self)

    def back(self) -> "std::vector< std::complex< double > >::value_type const &":
        r"""back(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type const &"""
        return _runtime_swig.gr_vector_complexd_back(self)

    def assign(self, n: "std::vector< std::complex< double > >::size_type", x: "std::vector< std::complex< double > >::value_type const &") -> "void":
        r"""assign(gr_vector_complexd self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vector_complexd self, std::vector< std::complex< double > >::size_type new_size)
        resize(gr_vector_complexd self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd_insert(self, *args)

    def reserve(self, n: "std::vector< std::complex< double > >::size_type") -> "void":
        r"""reserve(gr_vector_complexd self, std::vector< std::complex< double > >::size_type n)"""
        return _runtime_swig.gr_vector_complexd_reserve(self, n)

    def capacity(self) -> "std::vector< std::complex< double > >::size_type":
        r"""capacity(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vector_complexd

# Register gr_vector_complexd in _runtime_swig:
_runtime_swig.gr_vector_complexd_swigregister(gr_vector_complexd)

class gr_vector_vector_complexf(object):
    r"""Proxy of C++ std::vector< std::vector< std::complex< float > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vector_vector_complexf self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_vector_complexf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf___bool__(self)

    def __len__(self) -> "std::vector< std::vector< std::complex< float > > >::size_type":
        r"""__len__(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< std::complex< float > > >::difference_type", j: "std::vector< std::vector< std::complex< float > > >::difference_type") -> "std::vector< std::vector< std::complex< float >,std::allocator< std::complex< float > > >,std::allocator< std::vector< std::complex< float >,std::allocator< std::complex< float > > > > > *":
        r"""__getslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j) -> gr_vector_vector_complexf"""
        return _runtime_swig.gr_vector_vector_complexf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j)
        __setslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j, gr_vector_vector_complexf v)
        """
        return _runtime_swig.gr_vector_vector_complexf___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< std::complex< float > > >::difference_type", j: "std::vector< std::vector< std::complex< float > > >::difference_type") -> "void":
        r"""__delslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j)"""
        return _runtime_swig.gr_vector_vector_complexf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i)
        __delitem__(gr_vector_vector_complexf self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_vector_complexf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< std::complex< float > > >::value_type const &":
        r"""
        __getitem__(gr_vector_vector_complexf self, PySliceObject * slice) -> gr_vector_vector_complexf
        __getitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i) -> std::vector< std::vector< std::complex< float > > >::value_type const &
        """
        return _runtime_swig.gr_vector_vector_complexf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vector_vector_complexf self, PySliceObject * slice, gr_vector_vector_complexf v)
        __setitem__(gr_vector_vector_complexf self, PySliceObject * slice)
        __setitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< std::complex< float > > >::value_type":
        r"""pop(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type"""
        return _runtime_swig.gr_vector_vector_complexf_pop(self)

    def append(self, x: "std::vector< std::vector< std::complex< float > > >::value_type const &") -> "void":
        r"""append(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf_empty(self)

    def size(self) -> "std::vector< std::vector< std::complex< float > > >::size_type":
        r"""size(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf_size(self)

    def swap(self, v: "gr_vector_vector_complexf") -> "void":
        r"""swap(gr_vector_vector_complexf self, gr_vector_vector_complexf v)"""
        return _runtime_swig.gr_vector_vector_complexf_swap(self, v)

    def begin(self) -> "std::vector< std::vector< std::complex< float > > >::iterator":
        r"""begin(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexf_begin(self)

    def end(self) -> "std::vector< std::vector< std::complex< float > > >::iterator":
        r"""end(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexf_end(self)

    def rbegin(self) -> "std::vector< std::vector< std::complex< float > > >::reverse_iterator":
        r"""rbegin(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexf_rbegin(self)

    def rend(self) -> "std::vector< std::vector< std::complex< float > > >::reverse_iterator":
        r"""rend(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexf_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vector_vector_complexf self)"""
        return _runtime_swig.gr_vector_vector_complexf_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< std::complex< float > > >::allocator_type":
        r"""get_allocator(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::allocator_type"""
        return _runtime_swig.gr_vector_vector_complexf_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vector_vector_complexf self)"""
        return _runtime_swig.gr_vector_vector_complexf_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< std::complex< float > > >::iterator":
        r"""
        erase(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos) -> std::vector< std::vector< std::complex< float > > >::iterator
        erase(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator first, std::vector< std::vector< std::complex< float > > >::iterator last) -> std::vector< std::vector< std::complex< float > > >::iterator
        """
        return _runtime_swig.gr_vector_vector_complexf_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vector_vector_complexf self) -> gr_vector_vector_complexf
        __init__(gr_vector_vector_complexf self, gr_vector_vector_complexf other) -> gr_vector_vector_complexf
        __init__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type size) -> gr_vector_vector_complexf
        __init__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type size, std::vector< std::vector< std::complex< float > > >::value_type const & value) -> gr_vector_vector_complexf
        """
        _runtime_swig.gr_vector_vector_complexf_swiginit(self, _runtime_swig.new_gr_vector_vector_complexf(*args))

    def push_back(self, x: "std::vector< std::vector< std::complex< float > > >::value_type const &") -> "void":
        r"""push_back(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_push_back(self, x)

    def front(self) -> "std::vector< std::vector< std::complex< float > > >::value_type const &":
        r"""front(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type const &"""
        return _runtime_swig.gr_vector_vector_complexf_front(self)

    def back(self) -> "std::vector< std::vector< std::complex< float > > >::value_type const &":
        r"""back(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type const &"""
        return _runtime_swig.gr_vector_vector_complexf_back(self)

    def assign(self, n: "std::vector< std::vector< std::complex< float > > >::size_type", x: "std::vector< std::vector< std::complex< float > > >::value_type const &") -> "void":
        r"""assign(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type n, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type new_size)
        resize(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type new_size, std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos, std::vector< std::vector< std::complex< float > > >::value_type const & x) -> std::vector< std::vector< std::complex< float > > >::iterator
        insert(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos, std::vector< std::vector< std::complex< float > > >::size_type n, std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< std::complex< float > > >::size_type") -> "void":
        r"""reserve(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type n)"""
        return _runtime_swig.gr_vector_vector_complexf_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< std::complex< float > > >::size_type":
        r"""capacity(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vector_vector_complexf

# Register gr_vector_vector_complexf in _runtime_swig:
_runtime_swig.gr_vector_vector_complexf_swigregister(gr_vector_vector_complexf)

class gr_vector_vector_complexd(object):
    r"""Proxy of C++ std::vector< std::vector< std::complex< double > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(gr_vector_vector_complexd self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_vector_complexd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd___bool__(self)

    def __len__(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        r"""__len__(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< std::complex< double > > >::difference_type", j: "std::vector< std::vector< std::complex< double > > >::difference_type") -> "std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > > *":
        r"""__getslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j) -> gr_vector_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)
        __setslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j, gr_vector_vector_complexd v)
        """
        return _runtime_swig.gr_vector_vector_complexd___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< std::complex< double > > >::difference_type", j: "std::vector< std::vector< std::complex< double > > >::difference_type") -> "void":
        r"""__delslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)"""
        return _runtime_swig.gr_vector_vector_complexd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i)
        __delitem__(gr_vector_vector_complexd self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_vector_complexd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        r"""
        __getitem__(gr_vector_vector_complexd self, PySliceObject * slice) -> gr_vector_vector_complexd
        __getitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i) -> gr_vector_complexd
        """
        return _runtime_swig.gr_vector_vector_complexd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(gr_vector_vector_complexd self, PySliceObject * slice, gr_vector_vector_complexd v)
        __setitem__(gr_vector_vector_complexd self, PySliceObject * slice)
        __setitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< std::complex< double > > >::value_type":
        r"""pop(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_pop(self)

    def append(self, x: "gr_vector_complexd") -> "void":
        r"""append(gr_vector_vector_complexd self, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_append(self, x)

    def empty(self) -> "bool":
        r"""empty(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd_empty(self)

    def size(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        r"""size(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd_size(self)

    def swap(self, v: "gr_vector_vector_complexd") -> "void":
        r"""swap(gr_vector_vector_complexd self, gr_vector_vector_complexd v)"""
        return _runtime_swig.gr_vector_vector_complexd_swap(self, v)

    def begin(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        r"""begin(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexd_begin(self)

    def end(self) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        r"""end(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexd_end(self)

    def rbegin(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        r"""rbegin(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexd_rbegin(self)

    def rend(self) -> "std::vector< std::vector< std::complex< double > > >::reverse_iterator":
        r"""rend(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexd_rend(self)

    def clear(self) -> "void":
        r"""clear(gr_vector_vector_complexd self)"""
        return _runtime_swig.gr_vector_vector_complexd_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< std::complex< double > > >::allocator_type":
        r"""get_allocator(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::allocator_type"""
        return _runtime_swig.gr_vector_vector_complexd_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(gr_vector_vector_complexd self)"""
        return _runtime_swig.gr_vector_vector_complexd_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< std::complex< double > > >::iterator":
        r"""
        erase(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos) -> std::vector< std::vector< std::complex< double > > >::iterator
        erase(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator first, std::vector< std::vector< std::complex< double > > >::iterator last) -> std::vector< std::vector< std::complex< double > > >::iterator
        """
        return _runtime_swig.gr_vector_vector_complexd_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(gr_vector_vector_complexd self) -> gr_vector_vector_complexd
        __init__(gr_vector_vector_complexd self, gr_vector_vector_complexd other) -> gr_vector_vector_complexd
        __init__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type size) -> gr_vector_vector_complexd
        __init__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type size, gr_vector_complexd value) -> gr_vector_vector_complexd
        """
        _runtime_swig.gr_vector_vector_complexd_swiginit(self, _runtime_swig.new_gr_vector_vector_complexd(*args))

    def push_back(self, x: "gr_vector_complexd") -> "void":
        r"""push_back(gr_vector_vector_complexd self, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_push_back(self, x)

    def front(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        r"""front(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_front(self)

    def back(self) -> "std::vector< std::vector< std::complex< double > > >::value_type const &":
        r"""back(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_back(self)

    def assign(self, n: "std::vector< std::vector< std::complex< double > > >::size_type", x: "gr_vector_complexd") -> "void":
        r"""assign(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type n, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type new_size)
        resize(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type new_size, gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos, gr_vector_complexd x) -> std::vector< std::vector< std::complex< double > > >::iterator
        insert(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos, std::vector< std::vector< std::complex< double > > >::size_type n, gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< std::complex< double > > >::size_type") -> "void":
        r"""reserve(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type n)"""
        return _runtime_swig.gr_vector_vector_complexd_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< std::complex< double > > >::size_type":
        r"""capacity(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_gr_vector_vector_complexd

# Register gr_vector_vector_complexd in _runtime_swig:
_runtime_swig.gr_vector_vector_complexd_swigregister(gr_vector_vector_complexd)


def high_res_timer_now() -> "gr::high_res_timer_type":
    r"""
    high_res_timer_now() -> gr::high_res_timer_type
    Get the current time in ticks.
    """
    return _runtime_swig.high_res_timer_now()

def high_res_timer_now_perfmon() -> "gr::high_res_timer_type":
    r"""
    high_res_timer_now_perfmon() -> gr::high_res_timer_type
    Get the current time in ticks - for performance monitoring.
    """
    return _runtime_swig.high_res_timer_now_perfmon()

def high_res_timer_tps() -> "gr::high_res_timer_type":
    r"""
    high_res_timer_tps() -> gr::high_res_timer_type
    Get the number of ticks per second.
    """
    return _runtime_swig.high_res_timer_tps()

def high_res_timer_epoch() -> "gr::high_res_timer_type":
    r"""
    high_res_timer_epoch() -> gr::high_res_timer_type
    Get the tick count at the epoch.
    """
    return _runtime_swig.high_res_timer_epoch()
sizeof_char = _runtime_swig.sizeof_char

sizeof_short = _runtime_swig.sizeof_short

sizeof_int = _runtime_swig.sizeof_int

sizeof_float = _runtime_swig.sizeof_float

sizeof_double = _runtime_swig.sizeof_double

sizeof_gr_complex = _runtime_swig.sizeof_gr_complex

GR_MSB_FIRST = _runtime_swig.GR_MSB_FIRST

GR_LSB_FIRST = _runtime_swig.GR_LSB_FIRST

class basic_block_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::basic_block > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(basic_block_sptr self) -> basic_block_sptr
        __init__(basic_block_sptr self, basic_block p) -> basic_block_sptr
        """
        _runtime_swig.basic_block_sptr_swiginit(self, _runtime_swig.new_basic_block_sptr(*args))

    def __deref__(self) -> "gr::basic_block *":
        r"""__deref__(basic_block_sptr self) -> basic_block"""
        return _runtime_swig.basic_block_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_basic_block_sptr

    def name(self) -> "std::string":
        r"""
        name(basic_block_sptr self) -> std::string
        The name of the block
        """
        return _runtime_swig.basic_block_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(basic_block_sptr self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.basic_block_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(basic_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(basic_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(basic_block_sptr self) -> long"""
        return _runtime_swig.basic_block_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.basic_block_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(basic_block_sptr self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.basic_block_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(basic_block_sptr self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.basic_block_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(basic_block_sptr self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.basic_block_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(basic_block_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.basic_block_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(basic_block_sptr self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(basic_block_sptr self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(basic_block_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.basic_block_sptr_message_subscribers(self, which_port)

# Register basic_block_sptr in _runtime_swig:
_runtime_swig.basic_block_sptr_swigregister(basic_block_sptr)

class x_vector_basic_block_sptr(object):
    r"""Proxy of C++ std::vector< gr::basic_block_sptr > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(x_vector_basic_block_sptr self) -> SwigPyIterator"""
        return _runtime_swig.x_vector_basic_block_sptr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr___bool__(self)

    def __len__(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::size_type":
        r"""__len__(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr___len__(self)

    def __getslice__(self, i: "std::vector< boost::shared_ptr< gr::basic_block > >::difference_type", j: "std::vector< boost::shared_ptr< gr::basic_block > >::difference_type") -> "std::vector< boost::shared_ptr< gr::basic_block >,std::allocator< boost::shared_ptr< gr::basic_block > > > *":
        r"""__getslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j) -> x_vector_basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j)
        __setslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j, x_vector_basic_block_sptr v)
        """
        return _runtime_swig.x_vector_basic_block_sptr___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< boost::shared_ptr< gr::basic_block > >::difference_type", j: "std::vector< boost::shared_ptr< gr::basic_block > >::difference_type") -> "void":
        r"""__delslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j)"""
        return _runtime_swig.x_vector_basic_block_sptr___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i)
        __delitem__(x_vector_basic_block_sptr self, PySliceObject * slice)
        """
        return _runtime_swig.x_vector_basic_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< gr::basic_block > >::value_type const &":
        r"""
        __getitem__(x_vector_basic_block_sptr self, PySliceObject * slice) -> x_vector_basic_block_sptr
        __getitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i) -> basic_block_sptr
        """
        return _runtime_swig.x_vector_basic_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(x_vector_basic_block_sptr self, PySliceObject * slice, x_vector_basic_block_sptr v)
        __setitem__(x_vector_basic_block_sptr self, PySliceObject * slice)
        __setitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr___setitem__(self, *args)

    def pop(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::value_type":
        r"""pop(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_pop(self)

    def append(self, x: "basic_block_sptr") -> "void":
        r"""append(x_vector_basic_block_sptr self, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_append(self, x)

    def empty(self) -> "bool":
        r"""empty(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr_empty(self)

    def size(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::size_type":
        r"""size(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr_size(self)

    def swap(self, v: "x_vector_basic_block_sptr") -> "void":
        r"""swap(x_vector_basic_block_sptr self, x_vector_basic_block_sptr v)"""
        return _runtime_swig.x_vector_basic_block_sptr_swap(self, v)

    def begin(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::iterator":
        r"""begin(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_begin(self)

    def end(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::iterator":
        r"""end(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_end(self)

    def rbegin(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator":
        r"""rbegin(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_rbegin(self)

    def rend(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator":
        r"""rend(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_rend(self)

    def clear(self) -> "void":
        r"""clear(x_vector_basic_block_sptr self)"""
        return _runtime_swig.x_vector_basic_block_sptr_clear(self)

    def get_allocator(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::allocator_type":
        r"""get_allocator(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::allocator_type"""
        return _runtime_swig.x_vector_basic_block_sptr_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(x_vector_basic_block_sptr self)"""
        return _runtime_swig.x_vector_basic_block_sptr_pop_back(self)

    def erase(self, *args) -> "std::vector< boost::shared_ptr< gr::basic_block > >::iterator":
        r"""
        erase(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        erase(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator first, std::vector< boost::shared_ptr< gr::basic_block > >::iterator last) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        """
        return _runtime_swig.x_vector_basic_block_sptr_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(x_vector_basic_block_sptr self) -> x_vector_basic_block_sptr
        __init__(x_vector_basic_block_sptr self, x_vector_basic_block_sptr other) -> x_vector_basic_block_sptr
        __init__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type size) -> x_vector_basic_block_sptr
        __init__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type size, basic_block_sptr value) -> x_vector_basic_block_sptr
        """
        _runtime_swig.x_vector_basic_block_sptr_swiginit(self, _runtime_swig.new_x_vector_basic_block_sptr(*args))

    def push_back(self, x: "basic_block_sptr") -> "void":
        r"""push_back(x_vector_basic_block_sptr self, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_push_back(self, x)

    def front(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::value_type const &":
        r"""front(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_front(self)

    def back(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::value_type const &":
        r"""back(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_back(self)

    def assign(self, n: "std::vector< boost::shared_ptr< gr::basic_block > >::size_type", x: "basic_block_sptr") -> "void":
        r"""assign(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type new_size)
        resize(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type new_size, basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos, basic_block_sptr x) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        insert(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n, basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr_insert(self, *args)

    def reserve(self, n: "std::vector< boost::shared_ptr< gr::basic_block > >::size_type") -> "void":
        r"""reserve(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n)"""
        return _runtime_swig.x_vector_basic_block_sptr_reserve(self, n)

    def capacity(self) -> "std::vector< boost::shared_ptr< gr::basic_block > >::size_type":
        r"""capacity(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_x_vector_basic_block_sptr

# Register x_vector_basic_block_sptr in _runtime_swig:
_runtime_swig.x_vector_basic_block_sptr_swigregister(x_vector_basic_block_sptr)

class basic_block(object):
    r"""
    The abstract base class for all signal processing blocks.

    Basic blocks are the bare abstraction of an entity that has a name, a set of inputs and outputs, and a message queue. These are never instantiated directly; rather, this is the abstract parent class of both gr_hier_block, which is a recursive container, and block, which implements actual signal processing functions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_basic_block

    def name(self) -> "std::string":
        r"""
        name(basic_block self) -> std::string
        The name of the block
        """
        return _runtime_swig.basic_block_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(basic_block self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.basic_block_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(basic_block self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(basic_block self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(basic_block self) -> long"""
        return _runtime_swig.basic_block_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(basic_block self) -> basic_block_sptr"""
        return _runtime_swig.basic_block_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(basic_block self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.basic_block_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(basic_block self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.basic_block_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(basic_block self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.basic_block_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(basic_block self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.basic_block__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(basic_block self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(basic_block self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(basic_block self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.basic_block_message_subscribers(self, which_port)

# Register basic_block in _runtime_swig:
_runtime_swig.basic_block_swigregister(basic_block)


def block_ncurrently_allocated() -> "long":
    r"""block_ncurrently_allocated() -> long"""
    return _runtime_swig.block_ncurrently_allocated()

basic_block_sptr.__repr__ = lambda self: "<basic_block %s (%d)>" % (self.name(), self.unique_id ())

class block_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::block > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(block_sptr self) -> block_sptr
        __init__(block_sptr self, block p) -> block_sptr
        """
        _runtime_swig.block_sptr_swiginit(self, _runtime_swig.new_block_sptr(*args))

    def __deref__(self) -> "gr::block *":
        r"""__deref__(block_sptr self) -> block"""
        return _runtime_swig.block_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_block_sptr

    def history(self) -> "unsigned int":
        r"""
        history(block_sptr self) -> unsigned int
        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(block_sptr self, int which, int delay)
        declare_sample_delay(block_sptr self, unsigned int delay)
        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.


        This does not actively set the delay; it just tells the scheduler what the delay is.


        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""
        sample_delay(block_sptr self, int which) -> unsigned int
        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""
        set_output_multiple(block_sptr self, int multiple)
        Constrain the noutput_items argument passed to forecast and general_work.

        set_output_multiple causes the scheduler to ensure that the noutput_items argument passed to forecast and general_work will be an integer multiple of
        """
        return _runtime_swig.block_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(block_sptr self) -> int"""
        return _runtime_swig.block_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""
        relative_rate(block_sptr self) -> double
        return the approximate output rate / input rate
        """
        return _runtime_swig.block_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""
        relative_rate_i(block_sptr self) -> uint64_t
        return the numerator, or interpolation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""
        relative_rate_d(block_sptr self) -> uint64_t
        return the denominator, or decimation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""
        start(block_sptr self) -> bool
        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_sptr_start(self)

    def stop(self) -> "bool":
        r"""
        stop(block_sptr self) -> bool
        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""
        nitems_read(block_sptr self, unsigned int which_input) -> uint64_t
        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""
        nitems_written(block_sptr self, unsigned int which_output) -> uint64_t
        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(block_sptr self, std::string level)
        Set the logger's output level.

        Sets the level of the logger. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.block_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(block_sptr self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.block_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""
        max_noutput_items(block_sptr self) -> int
        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""
        set_max_noutput_items(block_sptr self, int m)
        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""
        unset_max_noutput_items(block_sptr self)
        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.


        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""
        is_set_max_noutput_items(block_sptr self) -> bool
        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""
        set_min_noutput_items(block_sptr self, int m)
        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""
        min_noutput_items(block_sptr self) -> int
        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""
        max_output_buffer(block_sptr self, int i) -> long
        Returns max buffer size on output port .
        """
        return _runtime_swig.block_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(block_sptr self, long max_output_buffer)
        set_max_output_buffer(block_sptr self, int port, long max_output_buffer)
        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""
        min_output_buffer(block_sptr self, int i) -> long
        Returns min buffer size on output port .
        """
        return _runtime_swig.block_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(block_sptr self, long min_output_buffer)
        set_min_output_buffer(block_sptr self, int port, long min_output_buffer)
        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""
        pc_noutput_items(block_sptr self) -> float
        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""
        pc_noutput_items_avg(block_sptr self) -> float
        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""
        pc_noutput_items_var(block_sptr self) -> float
        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""
        pc_nproduced(block_sptr self) -> float
        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""
        pc_nproduced_avg(block_sptr self) -> float
        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""
        pc_nproduced_var(block_sptr self) -> float
        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(block_sptr self, int which) -> float
        pc_input_buffers_full(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(block_sptr self, int which) -> float
        pc_input_buffers_full_avg(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(block_sptr self, int which) -> float
        pc_input_buffers_full_var(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(block_sptr self, int which) -> float
        pc_output_buffers_full(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  output buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(block_sptr self, int which) -> float
        pc_output_buffers_full_avg(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  output buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(block_sptr self, int which) -> float
        pc_output_buffers_full_var(block_sptr self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  output buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""
        pc_work_time(block_sptr self) -> float
        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""
        pc_work_time_avg(block_sptr self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""
        pc_work_time_var(block_sptr self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""
        pc_work_time_total(block_sptr self) -> float
        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""
        pc_throughput_avg(block_sptr self) -> float
        Gets average throughput.
        """
        return _runtime_swig.block_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(block_sptr self, std::vector< int,std::allocator< int > > const & mask)
        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(block_sptr self)
        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(block_sptr self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.
        """
        return _runtime_swig.block_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""
        active_thread_priority(block_sptr self) -> int
        Get the current thread priority in use.
        """
        return _runtime_swig.block_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""
        thread_priority(block_sptr self) -> int
        Get the current thread priority stored.
        """
        return _runtime_swig.block_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""
        set_thread_priority(block_sptr self, int priority) -> int
        Set the current thread priority.
        """
        return _runtime_swig.block_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""
        name(block_sptr self) -> std::string
        The name of the block
        """
        return _runtime_swig.block_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(block_sptr self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.block_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(block_sptr self) -> long"""
        return _runtime_swig.block_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.block_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(block_sptr self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.block_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(block_sptr self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.block_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(block_sptr self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.block_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(block_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.block_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(block_sptr self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(block_sptr self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(block_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.block_sptr_message_subscribers(self, which_port)

# Register block_sptr in _runtime_swig:
_runtime_swig.block_sptr_swigregister(block_sptr)

class x_vector_block_sptr(object):
    r"""Proxy of C++ std::vector< gr::block_sptr > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(x_vector_block_sptr self) -> SwigPyIterator"""
        return _runtime_swig.x_vector_block_sptr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr___bool__(self)

    def __len__(self) -> "std::vector< boost::shared_ptr< gr::block > >::size_type":
        r"""__len__(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr___len__(self)

    def __getslice__(self, i: "std::vector< boost::shared_ptr< gr::block > >::difference_type", j: "std::vector< boost::shared_ptr< gr::block > >::difference_type") -> "std::vector< boost::shared_ptr< gr::block >,std::allocator< boost::shared_ptr< gr::block > > > *":
        r"""__getslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j) -> x_vector_block_sptr"""
        return _runtime_swig.x_vector_block_sptr___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j)
        __setslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j, x_vector_block_sptr v)
        """
        return _runtime_swig.x_vector_block_sptr___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< boost::shared_ptr< gr::block > >::difference_type", j: "std::vector< boost::shared_ptr< gr::block > >::difference_type") -> "void":
        r"""__delslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j)"""
        return _runtime_swig.x_vector_block_sptr___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i)
        __delitem__(x_vector_block_sptr self, PySliceObject * slice)
        """
        return _runtime_swig.x_vector_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< boost::shared_ptr< gr::block > >::value_type const &":
        r"""
        __getitem__(x_vector_block_sptr self, PySliceObject * slice) -> x_vector_block_sptr
        __getitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i) -> block_sptr
        """
        return _runtime_swig.x_vector_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(x_vector_block_sptr self, PySliceObject * slice, x_vector_block_sptr v)
        __setitem__(x_vector_block_sptr self, PySliceObject * slice)
        __setitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr___setitem__(self, *args)

    def pop(self) -> "std::vector< boost::shared_ptr< gr::block > >::value_type":
        r"""pop(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_pop(self)

    def append(self, x: "block_sptr") -> "void":
        r"""append(x_vector_block_sptr self, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_append(self, x)

    def empty(self) -> "bool":
        r"""empty(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr_empty(self)

    def size(self) -> "std::vector< boost::shared_ptr< gr::block > >::size_type":
        r"""size(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr_size(self)

    def swap(self, v: "x_vector_block_sptr") -> "void":
        r"""swap(x_vector_block_sptr self, x_vector_block_sptr v)"""
        return _runtime_swig.x_vector_block_sptr_swap(self, v)

    def begin(self) -> "std::vector< boost::shared_ptr< gr::block > >::iterator":
        r"""begin(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::iterator"""
        return _runtime_swig.x_vector_block_sptr_begin(self)

    def end(self) -> "std::vector< boost::shared_ptr< gr::block > >::iterator":
        r"""end(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::iterator"""
        return _runtime_swig.x_vector_block_sptr_end(self)

    def rbegin(self) -> "std::vector< boost::shared_ptr< gr::block > >::reverse_iterator":
        r"""rbegin(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::reverse_iterator"""
        return _runtime_swig.x_vector_block_sptr_rbegin(self)

    def rend(self) -> "std::vector< boost::shared_ptr< gr::block > >::reverse_iterator":
        r"""rend(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::reverse_iterator"""
        return _runtime_swig.x_vector_block_sptr_rend(self)

    def clear(self) -> "void":
        r"""clear(x_vector_block_sptr self)"""
        return _runtime_swig.x_vector_block_sptr_clear(self)

    def get_allocator(self) -> "std::vector< boost::shared_ptr< gr::block > >::allocator_type":
        r"""get_allocator(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::allocator_type"""
        return _runtime_swig.x_vector_block_sptr_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(x_vector_block_sptr self)"""
        return _runtime_swig.x_vector_block_sptr_pop_back(self)

    def erase(self, *args) -> "std::vector< boost::shared_ptr< gr::block > >::iterator":
        r"""
        erase(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        erase(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator first, std::vector< boost::shared_ptr< gr::block > >::iterator last) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        """
        return _runtime_swig.x_vector_block_sptr_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(x_vector_block_sptr self) -> x_vector_block_sptr
        __init__(x_vector_block_sptr self, x_vector_block_sptr other) -> x_vector_block_sptr
        __init__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type size) -> x_vector_block_sptr
        __init__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type size, block_sptr value) -> x_vector_block_sptr
        """
        _runtime_swig.x_vector_block_sptr_swiginit(self, _runtime_swig.new_x_vector_block_sptr(*args))

    def push_back(self, x: "block_sptr") -> "void":
        r"""push_back(x_vector_block_sptr self, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_push_back(self, x)

    def front(self) -> "std::vector< boost::shared_ptr< gr::block > >::value_type const &":
        r"""front(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_front(self)

    def back(self) -> "std::vector< boost::shared_ptr< gr::block > >::value_type const &":
        r"""back(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_back(self)

    def assign(self, n: "std::vector< boost::shared_ptr< gr::block > >::size_type", x: "block_sptr") -> "void":
        r"""assign(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type n, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type new_size)
        resize(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type new_size, block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos, block_sptr x) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        insert(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos, std::vector< boost::shared_ptr< gr::block > >::size_type n, block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr_insert(self, *args)

    def reserve(self, n: "std::vector< boost::shared_ptr< gr::block > >::size_type") -> "void":
        r"""reserve(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type n)"""
        return _runtime_swig.x_vector_block_sptr_reserve(self, n)

    def capacity(self) -> "std::vector< boost::shared_ptr< gr::block > >::size_type":
        r"""capacity(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_x_vector_block_sptr

# Register x_vector_block_sptr in _runtime_swig:
_runtime_swig.x_vector_block_sptr_swigregister(x_vector_block_sptr)

class block(basic_block):
    r"""
    The abstract base class for all 'terminal' processing blocks.

    A signal processing flow is constructed by creating a tree of hierarchical blocks, which at any level may also contain terminal nodes that actually implement signal processing functions. This is the base class for all such leaf nodes.


    Blocks have a set of input streams and output streams. The input_signature and output_signature define the number of input streams and output streams respectively, and the type of the data items in each stream.


    Blocks report the number of items consumed on each input in general_work(), using consume() or consume_each().


    If the same number of items is produced on each output, the block returns that number from general_work(). Otherwise, the block calls produce() for each output, then returns WORK_CALLED_PRODUCE. The input and output rates are not required to be related.


    User derived blocks override two methods, forecast and general_work, to implement their signal processing behavior. forecast is called by the system scheduler to determine how many items are required on each input stream in order to produce a given number of output items.


    general_work is called to perform the signal processing in the block. It reads the input items and writes the output items.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_block

    def history(self) -> "unsigned int":
        r"""
        history(block self) -> unsigned int
        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(block self, int which, int delay)
        declare_sample_delay(block self, unsigned int delay)
        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.


        This does not actively set the delay; it just tells the scheduler what the delay is.


        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""
        sample_delay(block self, int which) -> unsigned int
        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""
        set_output_multiple(block self, int multiple)
        Constrain the noutput_items argument passed to forecast and general_work.

        set_output_multiple causes the scheduler to ensure that the noutput_items argument passed to forecast and general_work will be an integer multiple of
        """
        return _runtime_swig.block_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(block self) -> int"""
        return _runtime_swig.block_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""
        relative_rate(block self) -> double
        return the approximate output rate / input rate
        """
        return _runtime_swig.block_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""
        relative_rate_i(block self) -> uint64_t
        return the numerator, or interpolation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""
        relative_rate_d(block self) -> uint64_t
        return the denominator, or decimation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_relative_rate_d(self)

    def start(self) -> "bool":
        r"""
        start(block self) -> bool
        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_start(self)

    def stop(self) -> "bool":
        r"""
        stop(block self) -> bool
        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""
        nitems_read(block self, unsigned int which_input) -> uint64_t
        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""
        nitems_written(block self, unsigned int which_output) -> uint64_t
        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(block self, std::string level)
        Set the logger's output level.

        Sets the level of the logger. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.block_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(block self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.block_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""
        max_noutput_items(block self) -> int
        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""
        set_max_noutput_items(block self, int m)
        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""
        unset_max_noutput_items(block self)
        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.


        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""
        is_set_max_noutput_items(block self) -> bool
        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""
        set_min_noutput_items(block self, int m)
        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""
        min_noutput_items(block self) -> int
        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""
        max_output_buffer(block self, int i) -> long
        Returns max buffer size on output port .
        """
        return _runtime_swig.block_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(block self, long max_output_buffer)
        set_max_output_buffer(block self, int port, long max_output_buffer)
        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""
        min_output_buffer(block self, int i) -> long
        Returns min buffer size on output port .
        """
        return _runtime_swig.block_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(block self, long min_output_buffer)
        set_min_output_buffer(block self, int port, long min_output_buffer)
        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""
        pc_noutput_items(block self) -> float
        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""
        pc_noutput_items_avg(block self) -> float
        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""
        pc_noutput_items_var(block self) -> float
        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""
        pc_nproduced(block self) -> float
        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""
        pc_nproduced_avg(block self) -> float
        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""
        pc_nproduced_var(block self) -> float
        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(block self, int which) -> float
        pc_input_buffers_full(block self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(block self, int which) -> float
        pc_input_buffers_full_avg(block self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(block self, int which) -> float
        pc_input_buffers_full_var(block self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(block self, int which) -> float
        pc_output_buffers_full(block self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  output buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(block self, int which) -> float
        pc_output_buffers_full_avg(block self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  output buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(block self, int which) -> float
        pc_output_buffers_full_var(block self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  output buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""
        pc_work_time(block self) -> float
        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""
        pc_work_time_avg(block self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""
        pc_work_time_var(block self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""
        pc_work_time_total(block self) -> float
        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""
        pc_throughput_avg(block self) -> float
        Gets average throughput.
        """
        return _runtime_swig.block_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(block self, std::vector< int,std::allocator< int > > const & mask)
        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(block self)
        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(block self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.
        """
        return _runtime_swig.block_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""
        active_thread_priority(block self) -> int
        Get the current thread priority in use.
        """
        return _runtime_swig.block_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""
        thread_priority(block self) -> int
        Get the current thread priority stored.
        """
        return _runtime_swig.block_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""
        set_thread_priority(block self, int priority) -> int
        Set the current thread priority.
        """
        return _runtime_swig.block_set_thread_priority(self, priority)

# Register block in _runtime_swig:
_runtime_swig.block_swigregister(block)

class block_detail_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::block_detail > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(block_detail_sptr self) -> block_detail_sptr
        __init__(block_detail_sptr self, gr::block_detail * p) -> block_detail_sptr
        """
        _runtime_swig.block_detail_sptr_swiginit(self, _runtime_swig.new_block_detail_sptr(*args))

    def __deref__(self) -> "gr::block_detail *":
        r"""__deref__(block_detail_sptr self) -> gr::block_detail *"""
        return _runtime_swig.block_detail_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_block_detail_sptr

    def ninputs(self) -> "int":
        r"""ninputs(block_detail_sptr self) -> int"""
        return _runtime_swig.block_detail_sptr_ninputs(self)

    def noutputs(self) -> "int":
        r"""noutputs(block_detail_sptr self) -> int"""
        return _runtime_swig.block_detail_sptr_noutputs(self)

    def sink_p(self) -> "bool":
        r"""sink_p(block_detail_sptr self) -> bool"""
        return _runtime_swig.block_detail_sptr_sink_p(self)

    def source_p(self) -> "bool":
        r"""source_p(block_detail_sptr self) -> bool"""
        return _runtime_swig.block_detail_sptr_source_p(self)

    def set_input(self, which: "unsigned int", reader: "buffer_reader_sptr") -> "void":
        r"""set_input(block_detail_sptr self, unsigned int which, buffer_reader_sptr reader)"""
        return _runtime_swig.block_detail_sptr_set_input(self, which, reader)

    def input(self, which: "unsigned int") -> "gr::buffer_reader_sptr":
        r"""input(block_detail_sptr self, unsigned int which) -> buffer_reader_sptr"""
        return _runtime_swig.block_detail_sptr_input(self, which)

    def set_output(self, which: "unsigned int", buffer: "buffer_sptr") -> "void":
        r"""set_output(block_detail_sptr self, unsigned int which, buffer_sptr buffer)"""
        return _runtime_swig.block_detail_sptr_set_output(self, which, buffer)

    def output(self, which: "unsigned int") -> "gr::buffer_sptr":
        r"""output(block_detail_sptr self, unsigned int which) -> buffer_sptr"""
        return _runtime_swig.block_detail_sptr_output(self, which)

# Register block_detail_sptr in _runtime_swig:
_runtime_swig.block_detail_sptr_swigregister(block_detail_sptr)


def block_detail_ncurrently_allocated() -> "long":
    r"""block_detail_ncurrently_allocated() -> long"""
    return _runtime_swig.block_detail_ncurrently_allocated()
class buffer_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::buffer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(buffer_sptr self) -> buffer_sptr
        __init__(buffer_sptr self, gr::buffer * p) -> buffer_sptr
        """
        _runtime_swig.buffer_sptr_swiginit(self, _runtime_swig.new_buffer_sptr(*args))

    def __deref__(self) -> "gr::buffer *":
        r"""__deref__(buffer_sptr self) -> gr::buffer *"""
        return _runtime_swig.buffer_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_buffer_sptr

# Register buffer_sptr in _runtime_swig:
_runtime_swig.buffer_sptr_swigregister(buffer_sptr)

class buffer_reader_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::buffer_reader > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(buffer_reader_sptr self) -> buffer_reader_sptr
        __init__(buffer_reader_sptr self, gr::buffer_reader * p) -> buffer_reader_sptr
        """
        _runtime_swig.buffer_reader_sptr_swiginit(self, _runtime_swig.new_buffer_reader_sptr(*args))

    def __deref__(self) -> "gr::buffer_reader *":
        r"""__deref__(buffer_reader_sptr self) -> gr::buffer_reader *"""
        return _runtime_swig.buffer_reader_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_buffer_reader_sptr

# Register buffer_reader_sptr in _runtime_swig:
_runtime_swig.buffer_reader_sptr_swigregister(buffer_reader_sptr)


def buffer_ncurrently_allocated() -> "long":
    r"""
    buffer_ncurrently_allocated() -> long
    returns # of buffers currently allocated
    """
    return _runtime_swig.buffer_ncurrently_allocated()

def buffer_reader_ncurrently_allocated() -> "long":
    r"""
    buffer_reader_ncurrently_allocated() -> long
    returns # of buffer_readers currently allocated
    """
    return _runtime_swig.buffer_reader_ncurrently_allocated()

def prefix() -> "std::string const":
    r"""
    prefix() -> std::string const
    return SYSCONFDIR. Typically ${CMAKE_INSTALL_PREFIX}/etc or /etc
    """
    return _runtime_swig.prefix()

def sysconfdir() -> "std::string const":
    r"""
    sysconfdir() -> std::string const
    return SYSCONFDIR. Typically ${CMAKE_INSTALL_PREFIX}/etc or /etc
    """
    return _runtime_swig.sysconfdir()

def prefsdir() -> "std::string const":
    r"""
    prefsdir() -> std::string const
    return preferences file directory. Typically ${SYSCONFDIR}/etc/conf.d
    """
    return _runtime_swig.prefsdir()

def build_date() -> "std::string const":
    r"""
    build_date() -> std::string const
    return date/time of build, as set when 'cmake' is run
    """
    return _runtime_swig.build_date()

def version() -> "std::string const":
    r"""
    version() -> std::string const
    return version string defined by cmake (GrVersion.cmake)
    """
    return _runtime_swig.version()

def major_version() -> "std::string const":
    r"""
    major_version() -> std::string const
    return just the major version defined by cmake
    """
    return _runtime_swig.major_version()

def api_version() -> "std::string const":
    r"""
    api_version() -> std::string const
    return just the api version defined by cmake
    """
    return _runtime_swig.api_version()

def minor_version() -> "std::string const":
    r"""
    minor_version() -> std::string const
    returnjust the minor version defined by cmake
    """
    return _runtime_swig.minor_version()

def feval_dd_example(f: "gr::feval_dd *", x: "double") -> "double":
    r"""
    feval_dd_example(gr::feval_dd * f, double x) -> double
    trivial examples / test cases showing C++ calling Python code
    """
    return _runtime_swig.feval_dd_example(f, x)

def feval_cc_example(f: "gr::feval_cc *", x: "gr_complex") -> "gr_complex":
    r"""feval_cc_example(gr::feval_cc * f, gr_complex x) -> gr_complex"""
    return _runtime_swig.feval_cc_example(f, x)

def feval_ll_example(f: "gr::feval_ll *", x: "long") -> "long":
    r"""feval_ll_example(gr::feval_ll * f, long x) -> long"""
    return _runtime_swig.feval_ll_example(f, x)

def feval_example(f: "gr::feval *") -> "void":
    r"""feval_example(gr::feval * f)"""
    return _runtime_swig.feval_example(f)
class ensure_py_gil_state(object):
    r"""Proxy of C++ ensure_py_gil_state class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(ensure_py_gil_state self) -> ensure_py_gil_state"""
        _runtime_swig.ensure_py_gil_state_swiginit(self, _runtime_swig.new_ensure_py_gil_state())
    __swig_destroy__ = _runtime_swig.delete_ensure_py_gil_state

# Register ensure_py_gil_state in _runtime_swig:
_runtime_swig.ensure_py_gil_state_swigregister(ensure_py_gil_state)

class feval_dd(object):
    r"""Proxy of C++ gr::py_feval_dd class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def calleval(self, x: "double") -> "double":
        r"""calleval(feval_dd self, double x) -> double"""
        return _runtime_swig.feval_dd_calleval(self, x)
    __swig_destroy__ = _runtime_swig.delete_feval_dd

    def __init__(self):
        r"""__init__(feval_dd self) -> feval_dd"""
        if self.__class__ == feval_dd:
            _self = None
        else:
            _self = self
        _runtime_swig.feval_dd_swiginit(self, _runtime_swig.new_feval_dd(_self, ))
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_dd(self)
        return weakref.proxy(self)

    def eval(self, x: "double") -> "double":
        r"""
        eval(feval_dd self, double x) -> double
        override this to define the function
        """
        return _runtime_swig.feval_dd_eval(self, x)

# Register feval_dd in _runtime_swig:
_runtime_swig.feval_dd_swigregister(feval_dd)

class feval_cc(object):
    r"""Proxy of C++ gr::py_feval_cc class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def calleval(self, x: "gr_complex") -> "gr_complex":
        r"""calleval(feval_cc self, gr_complex x) -> gr_complex"""
        return _runtime_swig.feval_cc_calleval(self, x)
    __swig_destroy__ = _runtime_swig.delete_feval_cc

    def __init__(self):
        r"""__init__(feval_cc self) -> feval_cc"""
        if self.__class__ == feval_cc:
            _self = None
        else:
            _self = self
        _runtime_swig.feval_cc_swiginit(self, _runtime_swig.new_feval_cc(_self, ))
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_cc(self)
        return weakref.proxy(self)

    def eval(self, x: "gr_complex") -> "gr_complex":
        r"""
        eval(feval_cc self, gr_complex x) -> gr_complex
        override this to define the function
        """
        return _runtime_swig.feval_cc_eval(self, x)

# Register feval_cc in _runtime_swig:
_runtime_swig.feval_cc_swigregister(feval_cc)

class feval_ll(object):
    r"""Proxy of C++ gr::py_feval_ll class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def calleval(self, x: "long") -> "long":
        r"""calleval(feval_ll self, long x) -> long"""
        return _runtime_swig.feval_ll_calleval(self, x)
    __swig_destroy__ = _runtime_swig.delete_feval_ll

    def __init__(self):
        r"""__init__(feval_ll self) -> feval_ll"""
        if self.__class__ == feval_ll:
            _self = None
        else:
            _self = self
        _runtime_swig.feval_ll_swiginit(self, _runtime_swig.new_feval_ll(_self, ))
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_ll(self)
        return weakref.proxy(self)

    def eval(self, x: "long") -> "long":
        r"""
        eval(feval_ll self, long x) -> long
        override this to define the function
        """
        return _runtime_swig.feval_ll_eval(self, x)

# Register feval_ll in _runtime_swig:
_runtime_swig.feval_ll_swigregister(feval_ll)

class feval(object):
    r"""Proxy of C++ gr::py_feval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def calleval(self) -> "void":
        r"""calleval(feval self)"""
        return _runtime_swig.feval_calleval(self)
    __swig_destroy__ = _runtime_swig.delete_feval

    def __init__(self):
        r"""__init__(feval self) -> feval"""
        if self.__class__ == feval:
            _self = None
        else:
            _self = self
        _runtime_swig.feval_swiginit(self, _runtime_swig.new_feval(_self, ))
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval(self)
        return weakref.proxy(self)

    def eval(self) -> "void":
        r"""
        eval(feval self)
        override this to define the function
        """
        return _runtime_swig.feval_eval(self)

# Register feval in _runtime_swig:
_runtime_swig.feval_swigregister(feval)

class feval_p(object):
    r"""Proxy of C++ gr::py_feval_p class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def calleval(self, x: "swig_pmt_ptr") -> "void":
        r"""calleval(feval_p self, swig_pmt_ptr x)"""
        return _runtime_swig.feval_p_calleval(self, x)
    __swig_destroy__ = _runtime_swig.delete_feval_p

    def __init__(self):
        r"""__init__(feval_p self) -> feval_p"""
        if self.__class__ == feval_p:
            _self = None
        else:
            _self = self
        _runtime_swig.feval_p_swiginit(self, _runtime_swig.new_feval_p(_self, ))
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_p(self)
        return weakref.proxy(self)

    def eval(self, x: "swig_pmt_ptr") -> "void":
        r"""
        eval(feval_p self, swig_pmt_ptr x)
        override this to define the function
        """
        return _runtime_swig.feval_p_eval(self, x)

# Register feval_p in _runtime_swig:
_runtime_swig.feval_p_swigregister(feval_p)

class hier_block2_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::hier_block2 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(hier_block2_sptr self) -> hier_block2_sptr
        __init__(hier_block2_sptr self, hier_block2 p) -> hier_block2_sptr
        """
        _runtime_swig.hier_block2_sptr_swiginit(self, _runtime_swig.new_hier_block2_sptr(*args))

    def __deref__(self) -> "gr::hier_block2 *":
        r"""__deref__(hier_block2_sptr self) -> hier_block2"""
        return _runtime_swig.hier_block2_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_hier_block2_sptr

    def primitive_connect(self, *args) -> "void":
        r"""
        primitive_connect(hier_block2_sptr self, basic_block_sptr block)
        primitive_connect(hier_block2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.hier_block2_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args) -> "void":
        r"""
        primitive_msg_connect(hier_block2_sptr self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_connect(hier_block2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.hier_block2_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args) -> "void":
        r"""
        primitive_msg_disconnect(hier_block2_sptr self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_disconnect(hier_block2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.hier_block2_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args) -> "void":
        r"""
        primitive_disconnect(hier_block2_sptr self, basic_block_sptr block)
        primitive_disconnect(hier_block2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.hier_block2_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self) -> "void":
        r"""
        disconnect_all(hier_block2_sptr self)
        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.hier_block2_sptr_disconnect_all(self)

    def lock(self) -> "void":
        r"""
        lock(hier_block2_sptr self)
        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_sptr_lock(self)

    def unlock(self) -> "void":
        r"""
        unlock(hier_block2_sptr self)
        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_in(hier_block2_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.hier_block2_sptr_primitive_message_port_register_hier_in(self, port_id)

    def primitive_message_port_register_hier_out(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_out(hier_block2_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.hier_block2_sptr_primitive_message_port_register_hier_out(self, port_id)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(hier_block2_sptr self, std::vector< int,std::allocator< int > > const & mask)
        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.hier_block2_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(hier_block2_sptr self)
        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.hier_block2_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(hier_block2_sptr self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.hier_block2_sptr_processor_affinity(self)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(hier_block2_sptr self, std::string level)
        Set the logger's output level.

        Sets the level of the logger for all connected blocks. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.hier_block2_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(hier_block2_sptr self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.hier_block2_sptr_log_level(self)

    def max_output_buffer(self, i: "int") -> "size_t":
        r"""
        max_output_buffer(hier_block2_sptr self, int i) -> size_t
        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(hier_block2_sptr self, size_t max_output_buffer)
        set_max_output_buffer(hier_block2_sptr self, int port, size_t max_output_buffer)
        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "size_t":
        r"""
        min_output_buffer(hier_block2_sptr self, int i) -> size_t
        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(hier_block2_sptr self, size_t min_output_buffer)
        set_min_output_buffer(hier_block2_sptr self, int port, size_t min_output_buffer)
        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_sptr_set_min_output_buffer(self, *args)

    def to_hier_block2(self) -> "gr::hier_block2_sptr":
        r"""to_hier_block2(hier_block2_sptr self) -> hier_block2_sptr"""
        return _runtime_swig.hier_block2_sptr_to_hier_block2(self)

    def name(self) -> "std::string":
        r"""
        name(hier_block2_sptr self) -> std::string
        The name of the block
        """
        return _runtime_swig.hier_block2_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(hier_block2_sptr self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.hier_block2_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(hier_block2_sptr self) -> io_signature_sptr"""
        return _runtime_swig.hier_block2_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(hier_block2_sptr self) -> io_signature_sptr"""
        return _runtime_swig.hier_block2_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(hier_block2_sptr self) -> long"""
        return _runtime_swig.hier_block2_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(hier_block2_sptr self) -> basic_block_sptr"""
        return _runtime_swig.hier_block2_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(hier_block2_sptr self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.hier_block2_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(hier_block2_sptr self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.hier_block2_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(hier_block2_sptr self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.hier_block2_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(hier_block2_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.hier_block2_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(hier_block2_sptr self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.hier_block2_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(hier_block2_sptr self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.hier_block2_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(hier_block2_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.hier_block2_sptr_message_subscribers(self, which_port)

# Register hier_block2_sptr in _runtime_swig:
_runtime_swig.hier_block2_sptr_swigregister(hier_block2_sptr)


def hier_block2_swig(name: "std::string const", input_signature: "io_signature_sptr", output_signature: "io_signature_sptr") -> "gr::hier_block2_sptr":
    r"""
    hier_block2_swig(std::string const name, io_signature_sptr input_signature, io_signature_sptr output_signature) -> hier_block2_sptr
    public constructor for hier_block2
    """
    return _runtime_swig.hier_block2_swig(name, input_signature, output_signature)
class hier_block2(basic_block):
    r"""Hierarchical container class for gr::block's and gr::hier_block2's."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_hier_block2

    def primitive_connect(self, *args) -> "void":
        r"""
        primitive_connect(hier_block2 self, basic_block_sptr block)
        primitive_connect(hier_block2 self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.hier_block2_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args) -> "void":
        r"""
        primitive_msg_connect(hier_block2 self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_connect(hier_block2 self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.hier_block2_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args) -> "void":
        r"""
        primitive_msg_disconnect(hier_block2 self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_disconnect(hier_block2 self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.hier_block2_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args) -> "void":
        r"""
        primitive_disconnect(hier_block2 self, basic_block_sptr block)
        primitive_disconnect(hier_block2 self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.hier_block2_primitive_disconnect(self, *args)

    def disconnect_all(self) -> "void":
        r"""
        disconnect_all(hier_block2 self)
        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.hier_block2_disconnect_all(self)

    def lock(self) -> "void":
        r"""
        lock(hier_block2 self)
        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_lock(self)

    def unlock(self) -> "void":
        r"""
        unlock(hier_block2 self)
        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_unlock(self)

    def primitive_message_port_register_hier_in(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_in(hier_block2 self, swig_pmt_ptr port_id)"""
        return _runtime_swig.hier_block2_primitive_message_port_register_hier_in(self, port_id)

    def primitive_message_port_register_hier_out(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_out(hier_block2 self, swig_pmt_ptr port_id)"""
        return _runtime_swig.hier_block2_primitive_message_port_register_hier_out(self, port_id)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(hier_block2 self, std::vector< int,std::allocator< int > > const & mask)
        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.hier_block2_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(hier_block2 self)
        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.hier_block2_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(hier_block2 self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.hier_block2_processor_affinity(self)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(hier_block2 self, std::string level)
        Set the logger's output level.

        Sets the level of the logger for all connected blocks. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.hier_block2_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(hier_block2 self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.hier_block2_log_level(self)

    def max_output_buffer(self, i: "int") -> "size_t":
        r"""
        max_output_buffer(hier_block2 self, int i) -> size_t
        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(hier_block2 self, size_t max_output_buffer)
        set_max_output_buffer(hier_block2 self, int port, size_t max_output_buffer)
        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "size_t":
        r"""
        min_output_buffer(hier_block2 self, int i) -> size_t
        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(hier_block2 self, size_t min_output_buffer)
        set_min_output_buffer(hier_block2 self, int port, size_t min_output_buffer)
        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_set_min_output_buffer(self, *args)

    def to_hier_block2(self) -> "gr::hier_block2_sptr":
        r"""to_hier_block2(hier_block2 self) -> hier_block2_sptr"""
        return _runtime_swig.hier_block2_to_hier_block2(self)

# Register hier_block2 in _runtime_swig:
_runtime_swig.hier_block2_swigregister(hier_block2)


def dot_graph(hierblock2: "hier_block2_sptr") -> "std::string":
    r"""
    dot_graph(hier_block2_sptr hierblock2) -> std::string
    Return hierarchical block's flow graph represented in dot language.
    """
    return _runtime_swig.dot_graph(hierblock2)
class io_signature(object):
    r"""
    i/o signature for input and output ports.

    misc

    Constructor Specific Documentation:

    Create an i/o signature.

    Args:
        min_streams : specify minimum number of streams (>= 0)
        max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
        sizeof_stream_item : specify the size of the items in each stream
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_io_signature

    @staticmethod
    def make(min_streams: "int", max_streams: "int", sizeof_stream_item: "int") -> "gr::io_signature::sptr":
        r"""
        make(int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr
        i/o signature for input and output ports.

        misc

        Constructor Specific Documentation:

        Create an i/o signature.

        Args:
            min_streams : specify minimum number of streams (>= 0)
            max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
            sizeof_stream_item : specify the size of the items in each stream
        """
        return _runtime_swig.io_signature_make(min_streams, max_streams, sizeof_stream_item)

    @staticmethod
    def make2(min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int") -> "gr::io_signature::sptr":
        r"""
        make2(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr
        Create an i/o signature.
        """
        return _runtime_swig.io_signature_make2(min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2)

    @staticmethod
    def make3(min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int", sizeof_stream_item3: "int") -> "gr::io_signature::sptr":
        r"""
        make3(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, int sizeof_stream_item3) -> io_signature_sptr
        Create an i/o signature.
        """
        return _runtime_swig.io_signature_make3(min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2, sizeof_stream_item3)

    @staticmethod
    def makev(min_streams: "int", max_streams: "int", sizeof_stream_items: "std::vector< int,std::allocator< int > > const &") -> "gr::io_signature::sptr":
        r"""
        makev(int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr
        Create an i/o signature.

        If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
        """
        return _runtime_swig.io_signature_makev(min_streams, max_streams, sizeof_stream_items)

    def min_streams(self) -> "int":
        r"""min_streams(io_signature self) -> int"""
        return _runtime_swig.io_signature_min_streams(self)

    def max_streams(self) -> "int":
        r"""max_streams(io_signature self) -> int"""
        return _runtime_swig.io_signature_max_streams(self)

    def sizeof_stream_item(self, index: "int") -> "int":
        r"""sizeof_stream_item(io_signature self, int index) -> int"""
        return _runtime_swig.io_signature_sizeof_stream_item(self, index)

    def sizeof_stream_items(self) -> "std::vector< int,std::allocator< int > >":
        r"""sizeof_stream_items(io_signature self) -> std::vector< int,std::allocator< int > >"""
        return _runtime_swig.io_signature_sizeof_stream_items(self)

# Register io_signature in _runtime_swig:
_runtime_swig.io_signature_swigregister(io_signature)

def io_signature_make(min_streams: "int", max_streams: "int", sizeof_stream_item: "int") -> "gr::io_signature::sptr":
    r"""
    io_signature_make(int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr
    i/o signature for input and output ports.

    misc

    Constructor Specific Documentation:

    Create an i/o signature.

    Args:
        min_streams : specify minimum number of streams (>= 0)
        max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
        sizeof_stream_item : specify the size of the items in each stream
    """
    return _runtime_swig.io_signature_make(min_streams, max_streams, sizeof_stream_item)

def io_signature_make2(min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int") -> "gr::io_signature::sptr":
    r"""
    io_signature_make2(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr
    Create an i/o signature.
    """
    return _runtime_swig.io_signature_make2(min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2)

def io_signature_make3(min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int", sizeof_stream_item3: "int") -> "gr::io_signature::sptr":
    r"""
    io_signature_make3(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, int sizeof_stream_item3) -> io_signature_sptr
    Create an i/o signature.
    """
    return _runtime_swig.io_signature_make3(min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2, sizeof_stream_item3)

def io_signature_makev(min_streams: "int", max_streams: "int", sizeof_stream_items: "std::vector< int,std::allocator< int > > const &") -> "gr::io_signature::sptr":
    r"""
    io_signature_makev(int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr
    Create an i/o signature.

    If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
    """
    return _runtime_swig.io_signature_makev(min_streams, max_streams, sizeof_stream_items)

class io_signature_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::io_signature > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(io_signature_sptr self) -> io_signature_sptr
        __init__(io_signature_sptr self, io_signature p) -> io_signature_sptr
        """
        _runtime_swig.io_signature_sptr_swiginit(self, _runtime_swig.new_io_signature_sptr(*args))

    def __deref__(self) -> "gr::io_signature *":
        r"""__deref__(io_signature_sptr self) -> io_signature"""
        return _runtime_swig.io_signature_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_io_signature_sptr

    def make(self, min_streams: "int", max_streams: "int", sizeof_stream_item: "int") -> "gr::io_signature::sptr":
        r"""
        make(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr
        i/o signature for input and output ports.

        misc

        Constructor Specific Documentation:

        Create an i/o signature.

        Args:
            min_streams : specify minimum number of streams (>= 0)
            max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
            sizeof_stream_item : specify the size of the items in each stream
        """
        return _runtime_swig.io_signature_sptr_make(self, min_streams, max_streams, sizeof_stream_item)

    def make2(self, min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int") -> "gr::io_signature::sptr":
        r"""
        make2(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr
        Create an i/o signature.
        """
        return _runtime_swig.io_signature_sptr_make2(self, min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2)

    def make3(self, min_streams: "int", max_streams: "int", sizeof_stream_item1: "int", sizeof_stream_item2: "int", sizeof_stream_item3: "int") -> "gr::io_signature::sptr":
        r"""
        make3(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, int sizeof_stream_item3) -> io_signature_sptr
        Create an i/o signature.
        """
        return _runtime_swig.io_signature_sptr_make3(self, min_streams, max_streams, sizeof_stream_item1, sizeof_stream_item2, sizeof_stream_item3)

    def makev(self, min_streams: "int", max_streams: "int", sizeof_stream_items: "std::vector< int,std::allocator< int > > const &") -> "gr::io_signature::sptr":
        r"""
        makev(io_signature_sptr self, int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr
        Create an i/o signature.

        If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
        """
        return _runtime_swig.io_signature_sptr_makev(self, min_streams, max_streams, sizeof_stream_items)

    def min_streams(self) -> "int":
        r"""min_streams(io_signature_sptr self) -> int"""
        return _runtime_swig.io_signature_sptr_min_streams(self)

    def max_streams(self) -> "int":
        r"""max_streams(io_signature_sptr self) -> int"""
        return _runtime_swig.io_signature_sptr_max_streams(self)

    def sizeof_stream_item(self, index: "int") -> "int":
        r"""sizeof_stream_item(io_signature_sptr self, int index) -> int"""
        return _runtime_swig.io_signature_sptr_sizeof_stream_item(self, index)

    def sizeof_stream_items(self) -> "std::vector< int,std::allocator< int > >":
        r"""sizeof_stream_items(io_signature_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _runtime_swig.io_signature_sptr_sizeof_stream_items(self)

# Register io_signature_sptr in _runtime_swig:
_runtime_swig.io_signature_sptr_swigregister(io_signature_sptr)


io_signature_sptr.__repr__ = lambda self: "<io_signature: %d, %d>" % (self.min_streams(), self.max_streams())
io_signaturev = io_signature.makev;
io_signature3 = io_signature.make3;
io_signature2 = io_signature.make2;
io_signature = io_signature.make;

class message(object):
    r"""
    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    Constructor Specific Documentation:

    public constructor for message

    Args:
        type : 
        arg1 : 
        arg2 : 
        length : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def make(type: "long"=0, arg1: "double"=0, arg2: "double"=0, length: "size_t"=0) -> "gr::message::sptr":
        r"""
        make(long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr
        Message class.

        The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

        Constructor Specific Documentation:

        public constructor for message

        Args:
            type : 
            arg1 : 
            arg2 : 
            length : 
        """
        return _runtime_swig.message_make(type, arg1, arg2, length)

    @staticmethod
    def make_from_string(s: "std::string const", type: "long"=0, arg1: "double"=0, arg2: "double"=0) -> "gr::message::sptr":
        r"""make_from_string(std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
        return _runtime_swig.message_make_from_string(s, type, arg1, arg2)
    __swig_destroy__ = _runtime_swig.delete_message

    def type(self) -> "long":
        r"""type(message self) -> long"""
        return _runtime_swig.message_type(self)

    def arg1(self) -> "double":
        r"""arg1(message self) -> double"""
        return _runtime_swig.message_arg1(self)

    def arg2(self) -> "double":
        r"""arg2(message self) -> double"""
        return _runtime_swig.message_arg2(self)

    def set_type(self, type: "long") -> "void":
        r"""set_type(message self, long type)"""
        return _runtime_swig.message_set_type(self, type)

    def set_arg1(self, arg1: "double") -> "void":
        r"""set_arg1(message self, double arg1)"""
        return _runtime_swig.message_set_arg1(self, arg1)

    def set_arg2(self, arg2: "double") -> "void":
        r"""set_arg2(message self, double arg2)"""
        return _runtime_swig.message_set_arg2(self, arg2)

    def length(self) -> "size_t":
        r"""
        length(message self) -> size_t
        Return the number of elements in v.
        """
        return _runtime_swig.message_length(self)

    def to_string(self) -> "std::string":
        r"""to_string(message self) -> std::string"""
        val = _runtime_swig.message_to_string(self)

        import sys
        if sys.version_info[0] > 2:
          val =  val.encode("utf8", errors="surrogateescape")


        return val


# Register message in _runtime_swig:
_runtime_swig.message_swigregister(message)

def message_make(type: "long"=0, arg1: "double"=0, arg2: "double"=0, length: "size_t"=0) -> "gr::message::sptr":
    r"""
    message_make(long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr
    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    Constructor Specific Documentation:

    public constructor for message

    Args:
        type : 
        arg1 : 
        arg2 : 
        length : 
    """
    return _runtime_swig.message_make(type, arg1, arg2, length)

def message_make_from_string(s: "std::string const", type: "long"=0, arg1: "double"=0, arg2: "double"=0) -> "gr::message::sptr":
    r"""message_make_from_string(std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
    return _runtime_swig.message_make_from_string(s, type, arg1, arg2)


def message_ncurrently_allocated() -> "long":
    r"""message_ncurrently_allocated() -> long"""
    return _runtime_swig.message_ncurrently_allocated()
class message_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::message > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(message_sptr self) -> message_sptr
        __init__(message_sptr self, message p) -> message_sptr
        """
        _runtime_swig.message_sptr_swiginit(self, _runtime_swig.new_message_sptr(*args))

    def __deref__(self) -> "gr::message *":
        r"""__deref__(message_sptr self) -> message"""
        return _runtime_swig.message_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_message_sptr

    def make(self, type: "long"=0, arg1: "double"=0, arg2: "double"=0, length: "size_t"=0) -> "gr::message::sptr":
        r"""
        make(message_sptr self, long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr
        Message class.

        The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

        Constructor Specific Documentation:

        public constructor for message

        Args:
            type : 
            arg1 : 
            arg2 : 
            length : 
        """
        return _runtime_swig.message_sptr_make(self, type, arg1, arg2, length)

    def make_from_string(self, s: "std::string const", type: "long"=0, arg1: "double"=0, arg2: "double"=0) -> "gr::message::sptr":
        r"""make_from_string(message_sptr self, std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
        return _runtime_swig.message_sptr_make_from_string(self, s, type, arg1, arg2)

    def type(self) -> "long":
        r"""type(message_sptr self) -> long"""
        return _runtime_swig.message_sptr_type(self)

    def arg1(self) -> "double":
        r"""arg1(message_sptr self) -> double"""
        return _runtime_swig.message_sptr_arg1(self)

    def arg2(self) -> "double":
        r"""arg2(message_sptr self) -> double"""
        return _runtime_swig.message_sptr_arg2(self)

    def set_type(self, type: "long") -> "void":
        r"""set_type(message_sptr self, long type)"""
        return _runtime_swig.message_sptr_set_type(self, type)

    def set_arg1(self, arg1: "double") -> "void":
        r"""set_arg1(message_sptr self, double arg1)"""
        return _runtime_swig.message_sptr_set_arg1(self, arg1)

    def set_arg2(self, arg2: "double") -> "void":
        r"""set_arg2(message_sptr self, double arg2)"""
        return _runtime_swig.message_sptr_set_arg2(self, arg2)

    def length(self) -> "size_t":
        r"""
        length(message_sptr self) -> size_t
        Return the number of elements in v.
        """
        return _runtime_swig.message_sptr_length(self)

    def to_string(self) -> "std::string":
        r"""to_string(message_sptr self) -> std::string"""
        val = _runtime_swig.message_sptr_to_string(self)

        import sys
        if sys.version_info[0] > 2:
          val =  val.encode("utf8", errors="surrogateescape")


        return val


# Register message_sptr in _runtime_swig:
_runtime_swig.message_sptr_swigregister(message_sptr)


message_from_string = message.make_from_string
message = message.make

class msg_handler(object):
    r"""abstract class of message handlers"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_msg_handler

    def handle(self, msg: "message_sptr") -> "void":
        r"""
        handle(msg_handler self, message_sptr msg)
        handle
        """
        return _runtime_swig.msg_handler_handle(self, msg)

# Register msg_handler in _runtime_swig:
_runtime_swig.msg_handler_swigregister(msg_handler)

class msg_queue(msg_handler):
    r"""
    thread-safe message queue

    Constructor Specific Documentation:



    Args:
        limit : 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(limit: "unsigned int"=0) -> "gr::msg_queue::sptr":
        r"""
        make(unsigned int limit=0) -> msg_queue_sptr
        thread-safe message queue

        Constructor Specific Documentation:



        Args:
            limit : 
        """
        return _runtime_swig.msg_queue_make(limit)
    __swig_destroy__ = _runtime_swig.delete_msg_queue

    def delete_head_nowait(self) -> "gr::message::sptr":
        r"""
        delete_head_nowait(msg_queue self) -> message_sptr
        If there's a message in the q, delete it and return it. If no message is available, return 0.
        """
        return _runtime_swig.msg_queue_delete_head_nowait(self)

    def empty_p(self) -> "bool":
        r"""
        empty_p(msg_queue self) -> bool
        is the queue empty?
        """
        return _runtime_swig.msg_queue_empty_p(self)

    def full_p(self) -> "bool":
        r"""
        full_p(msg_queue self) -> bool
        is the queue full?
        """
        return _runtime_swig.msg_queue_full_p(self)

    def count(self) -> "unsigned int":
        r"""
        count(msg_queue self) -> unsigned int
        return number of messages in queue
        """
        return _runtime_swig.msg_queue_count(self)

    def flush(self) -> "void":
        r"""
        flush(msg_queue self)
        Delete all messages from the queue.
        """
        return _runtime_swig.msg_queue_flush(self)

# Register msg_queue in _runtime_swig:
_runtime_swig.msg_queue_swigregister(msg_queue)

def msg_queue_make(limit: "unsigned int"=0) -> "gr::msg_queue::sptr":
    r"""
    msg_queue_make(unsigned int limit=0) -> msg_queue_sptr
    thread-safe message queue

    Constructor Specific Documentation:



    Args:
        limit : 
    """
    return _runtime_swig.msg_queue_make(limit)


def py_msg_queue__delete_head(q: "msg_queue_sptr") -> "gr::message::sptr":
    r"""py_msg_queue__delete_head(msg_queue_sptr q) -> message_sptr"""
    return _runtime_swig.py_msg_queue__delete_head(q)

def py_msg_queue__insert_tail(q: "msg_queue_sptr", msg: "message_sptr") -> "void":
    r"""py_msg_queue__insert_tail(msg_queue_sptr q, message_sptr msg)"""
    return _runtime_swig.py_msg_queue__insert_tail(q, msg)
class msg_queue_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::msg_queue > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(msg_queue_sptr self) -> msg_queue_sptr
        __init__(msg_queue_sptr self, msg_queue p) -> msg_queue_sptr
        """
        _runtime_swig.msg_queue_sptr_swiginit(self, _runtime_swig.new_msg_queue_sptr(*args))

    def __deref__(self) -> "gr::msg_queue *":
        r"""__deref__(msg_queue_sptr self) -> msg_queue"""
        return _runtime_swig.msg_queue_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_msg_queue_sptr

    def make(self, limit: "unsigned int"=0) -> "gr::msg_queue::sptr":
        r"""
        make(msg_queue_sptr self, unsigned int limit=0) -> msg_queue_sptr
        thread-safe message queue

        Constructor Specific Documentation:



        Args:
            limit : 
        """
        return _runtime_swig.msg_queue_sptr_make(self, limit)

    def delete_head_nowait(self) -> "gr::message::sptr":
        r"""
        delete_head_nowait(msg_queue_sptr self) -> message_sptr
        If there's a message in the q, delete it and return it. If no message is available, return 0.
        """
        return _runtime_swig.msg_queue_sptr_delete_head_nowait(self)

    def empty_p(self) -> "bool":
        r"""
        empty_p(msg_queue_sptr self) -> bool
        is the queue empty?
        """
        return _runtime_swig.msg_queue_sptr_empty_p(self)

    def full_p(self) -> "bool":
        r"""
        full_p(msg_queue_sptr self) -> bool
        is the queue full?
        """
        return _runtime_swig.msg_queue_sptr_full_p(self)

    def count(self) -> "unsigned int":
        r"""
        count(msg_queue_sptr self) -> unsigned int
        return number of messages in queue
        """
        return _runtime_swig.msg_queue_sptr_count(self)

    def flush(self) -> "void":
        r"""
        flush(msg_queue_sptr self)
        Delete all messages from the queue.
        """
        return _runtime_swig.msg_queue_sptr_flush(self)

    def handle(self, msg: "message_sptr") -> "void":
        r"""
        handle(msg_queue_sptr self, message_sptr msg)
        handle
        """
        return _runtime_swig.msg_queue_sptr_handle(self, msg)

# Register msg_queue_sptr in _runtime_swig:
_runtime_swig.msg_queue_sptr_swigregister(msg_queue_sptr)


msg_queue_sptr.delete_head = py_msg_queue__delete_head
msg_queue_sptr.insert_tail = py_msg_queue__insert_tail
msg_queue_sptr.handle = py_msg_queue__insert_tail
msg_queue = msg_queue.make

class prefs(object):
    r"""
    Base class for representing user preferences a la windows INI files.

    The real implementation is in Python, and is accessible from C++ via the magic of SWIG directors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def singleton() -> "gr::prefs *":
        r"""singleton() -> prefs"""
        return _runtime_swig.prefs_singleton()

    def add_config_file(self, configfile: "std::string const &") -> "void":
        r"""
        add_config_file(prefs self, std::string const & configfile)
        If specifying a file name, this opens that specific configuration file of the standard form containing sections and key-value pairs:
        """
        return _runtime_swig.prefs_add_config_file(self, configfile)
    __swig_destroy__ = _runtime_swig.delete_prefs

    def to_string(self) -> "std::string":
        r"""
        to_string(prefs self) -> std::string
        Returns the configuration options as a string.
        """
        return _runtime_swig.prefs_to_string(self)

    def save(self) -> "void":
        r"""
        save(prefs self)
        Saves the configuration settings to ${HOME}/.gnuradio/config.conf.

        WARNING: this will overwrite your current config.conf file.
        """
        return _runtime_swig.prefs_save(self)

    def has_section(self, section: "std::string const &") -> "bool":
        r"""
        has_section(prefs self, std::string const & section) -> bool
        Does  exist?
        """
        return _runtime_swig.prefs_has_section(self, section)

    def has_option(self, section: "std::string const &", option: "std::string const &") -> "bool":
        r"""
        has_option(prefs self, std::string const & section, std::string const & option) -> bool
        Does  exist?
        """
        return _runtime_swig.prefs_has_option(self, section, option)

    def get_string(self, section: "std::string const &", option: "std::string const &", default_val: "std::string const &") -> "std::string const":
        r"""
        get_string(prefs self, std::string const & section, std::string const & option, std::string const & default_val) -> std::string const
        If option exists return associated value; else default_val.
        """
        return _runtime_swig.prefs_get_string(self, section, option, default_val)

    def set_string(self, section: "std::string const &", option: "std::string const &", val: "std::string const &") -> "void":
        r"""
        set_string(prefs self, std::string const & section, std::string const & option, std::string const & val)
        Set or add a string  to  with value .
        """
        return _runtime_swig.prefs_set_string(self, section, option, val)

    def get_bool(self, section: "std::string const &", option: "std::string const &", default_val: "bool") -> "bool":
        r"""
        get_bool(prefs self, std::string const & section, std::string const & option, bool default_val) -> bool
        If option exists and value can be converted to bool, return it; else default_val.
        """
        return _runtime_swig.prefs_get_bool(self, section, option, default_val)

    def set_bool(self, section: "std::string const &", option: "std::string const &", val: "bool") -> "void":
        r"""
        set_bool(prefs self, std::string const & section, std::string const & option, bool val)
        Set or add a bool  to  with value .
        """
        return _runtime_swig.prefs_set_bool(self, section, option, val)

    def get_long(self, section: "std::string const &", option: "std::string const &", default_val: "long") -> "long":
        r"""
        get_long(prefs self, std::string const & section, std::string const & option, long default_val) -> long
        If option exists and value can be converted to long, return it; else default_val.
        """
        return _runtime_swig.prefs_get_long(self, section, option, default_val)

    def set_long(self, section: "std::string const &", option: "std::string const &", val: "long") -> "void":
        r"""
        set_long(prefs self, std::string const & section, std::string const & option, long val)
        Set or add a long  to  with value .
        """
        return _runtime_swig.prefs_set_long(self, section, option, val)

    def get_double(self, section: "std::string const &", option: "std::string const &", default_val: "double") -> "double":
        r"""
        get_double(prefs self, std::string const & section, std::string const & option, double default_val) -> double
        If option exists and value can be converted to double, return it; else default_val.
        """
        return _runtime_swig.prefs_get_double(self, section, option, default_val)

    def set_double(self, section: "std::string const &", option: "std::string const &", val: "double") -> "void":
        r"""
        set_double(prefs self, std::string const & section, std::string const & option, double val)
        Set or add a double  to  with value .
        """
        return _runtime_swig.prefs_set_double(self, section, option, val)

    def __init__(self):
        r"""
        __init__(prefs self) -> prefs
        Creates an object to read preference files.

        If no file name is given (empty arg list or ""), this opens up the standard GNU Radio configuration files in prefix/etc/gnuradio/conf.d as well as ~/.gnuradio/config.conf.


        Only access this through the singleton defined here:
        """
        _runtime_swig.prefs_swiginit(self, _runtime_swig.new_prefs())

# Register prefs in _runtime_swig:
_runtime_swig.prefs_swigregister(prefs)

def prefs_singleton() -> "gr::prefs *":
    r"""prefs_singleton() -> prefs"""
    return _runtime_swig.prefs_singleton()

RT_OK = _runtime_swig.RT_OK

RT_NOT_IMPLEMENTED = _runtime_swig.RT_NOT_IMPLEMENTED

RT_NO_PRIVS = _runtime_swig.RT_NO_PRIVS

RT_OTHER_ERROR = _runtime_swig.RT_OTHER_ERROR


def enable_realtime_scheduling() -> "gr::rt_status_t":
    r"""
    enable_realtime_scheduling() -> gr::rt_status_t
    If possible, enable "realtime" scheduling.

    In general, this means that the code will be scheduled before any non-realtime (normal) processes. Note that if your code contains an non-blocking infinite loop and you enable realtime scheduling, it's possible to hang the system.
    """
    return _runtime_swig.enable_realtime_scheduling()
class sync_block(block):
    r"""
    synchronous 1:1 input to output with history

    Override work to provide the signal processing implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_block

# Register sync_block in _runtime_swig:
_runtime_swig.sync_block_swigregister(sync_block)

class sync_decimator(sync_block):
    r"""
    synchronous N:1 input to output with history

    Override work to provide the signal processing implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_decimator

# Register sync_decimator in _runtime_swig:
_runtime_swig.sync_decimator_swigregister(sync_decimator)

class sync_interpolator(sync_block):
    r"""
    synchronous 1:N input to output with history

    Override work to provide the signal processing implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_interpolator

# Register sync_interpolator in _runtime_swig:
_runtime_swig.sync_interpolator_swigregister(sync_interpolator)

class tagged_stream_block(block):
    r"""
    Block that operates on PDUs in form of tagged streams.

    Override work to provide the signal processing implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_tagged_stream_block

# Register tagged_stream_block in _runtime_swig:
_runtime_swig.tagged_stream_block_swigregister(tagged_stream_block)

class tag_t(object):
    r"""Proxy of C++ gr::tag_t class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    offset = property(_runtime_swig.tag_t_offset_get, _runtime_swig.tag_t_offset_set, doc=r"""offset : uint64_t""")
    key = property(_runtime_swig.tag_t_key_get, _runtime_swig.tag_t_key_set, doc=r"""key : pmt::pmt_t""")
    value = property(_runtime_swig.tag_t_value_get, _runtime_swig.tag_t_value_set, doc=r"""value : pmt::pmt_t""")
    srcid = property(_runtime_swig.tag_t_srcid_get, _runtime_swig.tag_t_srcid_set, doc=r"""srcid : pmt::pmt_t""")
    marked_deleted = property(_runtime_swig.tag_t_marked_deleted_get, _runtime_swig.tag_t_marked_deleted_set, doc=r"""marked_deleted : std::vector<(long,std::allocator<(long)>)>""")

    @staticmethod
    def offset_compare(x: "tag_t", y: "tag_t") -> "bool":
        r"""offset_compare(tag_t x, tag_t y) -> bool"""
        return _runtime_swig.tag_t_offset_compare(x, y)

    def __eq__(self, t: "tag_t") -> "bool":
        r"""__eq__(tag_t self, tag_t t) -> bool"""
        return _runtime_swig.tag_t___eq__(self, t)

    def __init__(self, *args):
        r"""
        __init__(tag_t self) -> tag_t
        __init__(tag_t self, tag_t rhs) -> tag_t
        """
        _runtime_swig.tag_t_swiginit(self, _runtime_swig.new_tag_t(*args))
    __swig_destroy__ = _runtime_swig.delete_tag_t

# Register tag_t in _runtime_swig:
_runtime_swig.tag_t_swigregister(tag_t)

def tag_t_offset_compare(x: "tag_t", y: "tag_t") -> "bool":
    r"""tag_t_offset_compare(tag_t x, tag_t y) -> bool"""
    return _runtime_swig.tag_t_offset_compare(x, y)

class tags_vector_t(object):
    r"""Proxy of C++ std::vector< gr::tag_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(tags_vector_t self) -> SwigPyIterator"""
        return _runtime_swig.tags_vector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t___bool__(self)

    def __len__(self) -> "std::vector< gr::tag_t >::size_type":
        r"""__len__(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t___len__(self)

    def __getslice__(self, i: "std::vector< gr::tag_t >::difference_type", j: "std::vector< gr::tag_t >::difference_type") -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > > *":
        r"""__getslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j) -> tags_vector_t"""
        return _runtime_swig.tags_vector_t___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j)
        __setslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j, tags_vector_t v)
        """
        return _runtime_swig.tags_vector_t___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< gr::tag_t >::difference_type", j: "std::vector< gr::tag_t >::difference_type") -> "void":
        r"""__delslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j)"""
        return _runtime_swig.tags_vector_t___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i)
        __delitem__(tags_vector_t self, PySliceObject * slice)
        """
        return _runtime_swig.tags_vector_t___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gr::tag_t >::value_type const &":
        r"""
        __getitem__(tags_vector_t self, PySliceObject * slice) -> tags_vector_t
        __getitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i) -> tag_t
        """
        return _runtime_swig.tags_vector_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(tags_vector_t self, PySliceObject * slice, tags_vector_t v)
        __setitem__(tags_vector_t self, PySliceObject * slice)
        __setitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, tag_t x)
        """
        return _runtime_swig.tags_vector_t___setitem__(self, *args)

    def pop(self) -> "std::vector< gr::tag_t >::value_type":
        r"""pop(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_pop(self)

    def append(self, x: "tag_t") -> "void":
        r"""append(tags_vector_t self, tag_t x)"""
        return _runtime_swig.tags_vector_t_append(self, x)

    def empty(self) -> "bool":
        r"""empty(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t_empty(self)

    def size(self) -> "std::vector< gr::tag_t >::size_type":
        r"""size(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t_size(self)

    def swap(self, v: "tags_vector_t") -> "void":
        r"""swap(tags_vector_t self, tags_vector_t v)"""
        return _runtime_swig.tags_vector_t_swap(self, v)

    def begin(self) -> "std::vector< gr::tag_t >::iterator":
        r"""begin(tags_vector_t self) -> std::vector< gr::tag_t >::iterator"""
        return _runtime_swig.tags_vector_t_begin(self)

    def end(self) -> "std::vector< gr::tag_t >::iterator":
        r"""end(tags_vector_t self) -> std::vector< gr::tag_t >::iterator"""
        return _runtime_swig.tags_vector_t_end(self)

    def rbegin(self) -> "std::vector< gr::tag_t >::reverse_iterator":
        r"""rbegin(tags_vector_t self) -> std::vector< gr::tag_t >::reverse_iterator"""
        return _runtime_swig.tags_vector_t_rbegin(self)

    def rend(self) -> "std::vector< gr::tag_t >::reverse_iterator":
        r"""rend(tags_vector_t self) -> std::vector< gr::tag_t >::reverse_iterator"""
        return _runtime_swig.tags_vector_t_rend(self)

    def clear(self) -> "void":
        r"""clear(tags_vector_t self)"""
        return _runtime_swig.tags_vector_t_clear(self)

    def get_allocator(self) -> "std::vector< gr::tag_t >::allocator_type":
        r"""get_allocator(tags_vector_t self) -> std::vector< gr::tag_t >::allocator_type"""
        return _runtime_swig.tags_vector_t_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(tags_vector_t self)"""
        return _runtime_swig.tags_vector_t_pop_back(self)

    def erase(self, *args) -> "std::vector< gr::tag_t >::iterator":
        r"""
        erase(tags_vector_t self, std::vector< gr::tag_t >::iterator pos) -> std::vector< gr::tag_t >::iterator
        erase(tags_vector_t self, std::vector< gr::tag_t >::iterator first, std::vector< gr::tag_t >::iterator last) -> std::vector< gr::tag_t >::iterator
        """
        return _runtime_swig.tags_vector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(tags_vector_t self) -> tags_vector_t
        __init__(tags_vector_t self, tags_vector_t other) -> tags_vector_t
        __init__(tags_vector_t self, std::vector< gr::tag_t >::size_type size) -> tags_vector_t
        __init__(tags_vector_t self, std::vector< gr::tag_t >::size_type size, tag_t value) -> tags_vector_t
        """
        _runtime_swig.tags_vector_t_swiginit(self, _runtime_swig.new_tags_vector_t(*args))

    def push_back(self, x: "tag_t") -> "void":
        r"""push_back(tags_vector_t self, tag_t x)"""
        return _runtime_swig.tags_vector_t_push_back(self, x)

    def front(self) -> "std::vector< gr::tag_t >::value_type const &":
        r"""front(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_front(self)

    def back(self) -> "std::vector< gr::tag_t >::value_type const &":
        r"""back(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_back(self)

    def assign(self, n: "std::vector< gr::tag_t >::size_type", x: "tag_t") -> "void":
        r"""assign(tags_vector_t self, std::vector< gr::tag_t >::size_type n, tag_t x)"""
        return _runtime_swig.tags_vector_t_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(tags_vector_t self, std::vector< gr::tag_t >::size_type new_size)
        resize(tags_vector_t self, std::vector< gr::tag_t >::size_type new_size, tag_t x)
        """
        return _runtime_swig.tags_vector_t_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(tags_vector_t self, std::vector< gr::tag_t >::iterator pos, tag_t x) -> std::vector< gr::tag_t >::iterator
        insert(tags_vector_t self, std::vector< gr::tag_t >::iterator pos, std::vector< gr::tag_t >::size_type n, tag_t x)
        """
        return _runtime_swig.tags_vector_t_insert(self, *args)

    def reserve(self, n: "std::vector< gr::tag_t >::size_type") -> "void":
        r"""reserve(tags_vector_t self, std::vector< gr::tag_t >::size_type n)"""
        return _runtime_swig.tags_vector_t_reserve(self, n)

    def capacity(self) -> "std::vector< gr::tag_t >::size_type":
        r"""capacity(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_tags_vector_t

# Register tags_vector_t in _runtime_swig:
_runtime_swig.tags_vector_t_swigregister(tags_vector_t)

class top_block_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::top_block > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(top_block_sptr self) -> top_block_sptr
        __init__(top_block_sptr self, top_block p) -> top_block_sptr
        """
        _runtime_swig.top_block_sptr_swiginit(self, _runtime_swig.new_top_block_sptr(*args))

    def __deref__(self) -> "gr::top_block *":
        r"""__deref__(top_block_sptr self) -> top_block"""
        return _runtime_swig.top_block_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_top_block_sptr

    def start(self, max_noutput_items: "int"=100000000) -> "void":
        r"""
        start(top_block_sptr self, int max_noutput_items=100000000)
        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _runtime_swig.top_block_sptr_start(self, max_noutput_items)

    def stop(self) -> "void":
        r"""
        stop(top_block_sptr self)
        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _runtime_swig.top_block_sptr_stop(self)

    def lock(self) -> "void":
        r"""
        lock(top_block_sptr self)
        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_sptr_lock(self)

    def unlock(self) -> "void":
        r"""
        unlock(top_block_sptr self)
        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_sptr_unlock(self)

    def edge_list(self) -> "std::string":
        r"""
        edge_list(top_block_sptr self) -> std::string
        Returns a string that lists the edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_sptr_edge_list(self)

    def msg_edge_list(self) -> "std::string":
        r"""
        msg_edge_list(top_block_sptr self) -> std::string
        Returns a string that lists the msg edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_sptr_msg_edge_list(self)

    def dump(self) -> "void":
        r"""
        dump(top_block_sptr self)
        Displays flattened flowgraph edges and block connectivity
        """
        return _runtime_swig.top_block_sptr_dump(self)

    def max_noutput_items(self) -> "int":
        r"""
        max_noutput_items(top_block_sptr self) -> int
        Get the number of max noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, nmax: "int") -> "void":
        r"""
        set_max_noutput_items(top_block_sptr self, int nmax)
        Set the maximum number of noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_sptr_set_max_noutput_items(self, nmax)

    def to_top_block(self) -> "gr::top_block_sptr":
        r"""to_top_block(top_block_sptr self) -> top_block_sptr"""
        return _runtime_swig.top_block_sptr_to_top_block(self)

    def primitive_connect(self, *args) -> "void":
        r"""
        primitive_connect(top_block_sptr self, basic_block_sptr block)
        primitive_connect(top_block_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.top_block_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args) -> "void":
        r"""
        primitive_msg_connect(top_block_sptr self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_connect(top_block_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.top_block_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args) -> "void":
        r"""
        primitive_msg_disconnect(top_block_sptr self, basic_block_sptr src, swig_pmt_ptr srcport, basic_block_sptr dst, swig_pmt_ptr dstport)
        primitive_msg_disconnect(top_block_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.top_block_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args) -> "void":
        r"""
        primitive_disconnect(top_block_sptr self, basic_block_sptr block)
        primitive_disconnect(top_block_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.top_block_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self) -> "void":
        r"""
        disconnect_all(top_block_sptr self)
        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.top_block_sptr_disconnect_all(self)

    def primitive_message_port_register_hier_in(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_in(top_block_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.top_block_sptr_primitive_message_port_register_hier_in(self, port_id)

    def primitive_message_port_register_hier_out(self, port_id: "swig_pmt_ptr") -> "void":
        r"""primitive_message_port_register_hier_out(top_block_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.top_block_sptr_primitive_message_port_register_hier_out(self, port_id)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(top_block_sptr self, std::vector< int,std::allocator< int > > const & mask)
        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.top_block_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(top_block_sptr self)
        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.top_block_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(top_block_sptr self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.top_block_sptr_processor_affinity(self)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(top_block_sptr self, std::string level)
        Set the logger's output level.

        Sets the level of the logger for all connected blocks. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.top_block_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(top_block_sptr self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.top_block_sptr_log_level(self)

    def max_output_buffer(self, i: "int") -> "size_t":
        r"""
        max_output_buffer(top_block_sptr self, int i) -> size_t
        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.top_block_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(top_block_sptr self, size_t max_output_buffer)
        set_max_output_buffer(top_block_sptr self, int port, size_t max_output_buffer)
        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.top_block_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "size_t":
        r"""
        min_output_buffer(top_block_sptr self, int i) -> size_t
        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.top_block_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(top_block_sptr self, size_t min_output_buffer)
        set_min_output_buffer(top_block_sptr self, int port, size_t min_output_buffer)
        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.top_block_sptr_set_min_output_buffer(self, *args)

    def to_hier_block2(self) -> "gr::hier_block2_sptr":
        r"""to_hier_block2(top_block_sptr self) -> hier_block2_sptr"""
        return _runtime_swig.top_block_sptr_to_hier_block2(self)

    def name(self) -> "std::string":
        r"""
        name(top_block_sptr self) -> std::string
        The name of the block
        """
        return _runtime_swig.top_block_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(top_block_sptr self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.top_block_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(top_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.top_block_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(top_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.top_block_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(top_block_sptr self) -> long"""
        return _runtime_swig.top_block_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(top_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.top_block_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(top_block_sptr self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.top_block_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(top_block_sptr self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.top_block_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(top_block_sptr self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.top_block_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(top_block_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.top_block_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(top_block_sptr self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.top_block_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(top_block_sptr self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.top_block_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(top_block_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.top_block_sptr_message_subscribers(self, which_port)

# Register top_block_sptr in _runtime_swig:
_runtime_swig.top_block_sptr_swigregister(top_block_sptr)


def top_block_swig(name: "std::string const") -> "gr::top_block_sptr":
    r"""top_block_swig(std::string const name) -> top_block_sptr"""
    return _runtime_swig.top_block_swig(name)
class top_block(hier_block2):
    r"""Top-level hierarchical block representing a flowgraph."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_top_block

    def start(self, max_noutput_items: "int"=100000000) -> "void":
        r"""
        start(top_block self, int max_noutput_items=100000000)
        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _runtime_swig.top_block_start(self, max_noutput_items)

    def stop(self) -> "void":
        r"""
        stop(top_block self)
        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _runtime_swig.top_block_stop(self)

    def lock(self) -> "void":
        r"""
        lock(top_block self)
        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_lock(self)

    def unlock(self) -> "void":
        r"""
        unlock(top_block self)
        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.


        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_unlock(self)

    def edge_list(self) -> "std::string":
        r"""
        edge_list(top_block self) -> std::string
        Returns a string that lists the edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_edge_list(self)

    def msg_edge_list(self) -> "std::string":
        r"""
        msg_edge_list(top_block self) -> std::string
        Returns a string that lists the msg edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_msg_edge_list(self)

    def dump(self) -> "void":
        r"""
        dump(top_block self)
        Displays flattened flowgraph edges and block connectivity
        """
        return _runtime_swig.top_block_dump(self)

    def max_noutput_items(self) -> "int":
        r"""
        max_noutput_items(top_block self) -> int
        Get the number of max noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_max_noutput_items(self)

    def set_max_noutput_items(self, nmax: "int") -> "void":
        r"""
        set_max_noutput_items(top_block self, int nmax)
        Set the maximum number of noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_set_max_noutput_items(self, nmax)

    def to_top_block(self) -> "gr::top_block_sptr":
        r"""to_top_block(top_block self) -> top_block_sptr"""
        return _runtime_swig.top_block_to_top_block(self)

# Register top_block in _runtime_swig:
_runtime_swig.top_block_swigregister(top_block)


def top_block_run_unlocked(r: "top_block_sptr") -> "void":
    r"""top_block_run_unlocked(top_block_sptr r)"""
    return _runtime_swig.top_block_run_unlocked(r)

def top_block_start_unlocked(r: "top_block_sptr", max_noutput_items: "int") -> "void":
    r"""top_block_start_unlocked(top_block_sptr r, int max_noutput_items)"""
    return _runtime_swig.top_block_start_unlocked(r, max_noutput_items)

def top_block_wait_unlocked(r: "top_block_sptr") -> "void":
    r"""top_block_wait_unlocked(top_block_sptr r)"""
    return _runtime_swig.top_block_wait_unlocked(r)

def top_block_stop_unlocked(r: "top_block_sptr") -> "void":
    r"""top_block_stop_unlocked(top_block_sptr r)"""
    return _runtime_swig.top_block_stop_unlocked(r)

def top_block_unlock_unlocked(r: "top_block_sptr") -> "void":
    r"""top_block_unlock_unlocked(top_block_sptr r)"""
    return _runtime_swig.top_block_unlock_unlocked(r)

def dot_graph_tb(r: "top_block_sptr") -> "std::string":
    r"""dot_graph_tb(top_block_sptr r) -> std::string"""
    return _runtime_swig.dot_graph_tb(r)
class void_start_vector_t(object):
    r"""Proxy of C++ std::vector< void * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(void_start_vector_t self) -> SwigPyIterator"""
        return _runtime_swig.void_start_vector_t_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t___bool__(self)

    def __len__(self) -> "std::vector< void * >::size_type":
        r"""__len__(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t___len__(self)

    def __getslice__(self, i: "std::vector< void * >::difference_type", j: "std::vector< void * >::difference_type") -> "std::vector< void *,std::allocator< void * > > *":
        r"""__getslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j) -> void_start_vector_t"""
        return _runtime_swig.void_start_vector_t___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j)
        __setslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j, void_start_vector_t v)
        """
        return _runtime_swig.void_start_vector_t___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< void * >::difference_type", j: "std::vector< void * >::difference_type") -> "void":
        r"""__delslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j)"""
        return _runtime_swig.void_start_vector_t___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(void_start_vector_t self, std::vector< void * >::difference_type i)
        __delitem__(void_start_vector_t self, PySliceObject * slice)
        """
        return _runtime_swig.void_start_vector_t___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< void * >::value_type":
        r"""
        __getitem__(void_start_vector_t self, PySliceObject * slice) -> void_start_vector_t
        __getitem__(void_start_vector_t self, std::vector< void * >::difference_type i) -> std::vector< void * >::value_type
        """
        return _runtime_swig.void_start_vector_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(void_start_vector_t self, PySliceObject * slice, void_start_vector_t v)
        __setitem__(void_start_vector_t self, PySliceObject * slice)
        __setitem__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t___setitem__(self, *args)

    def pop(self) -> "std::vector< void * >::value_type":
        r"""pop(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_pop(self)

    def append(self, x: "std::vector< void * >::value_type") -> "void":
        r"""append(void_start_vector_t self, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_append(self, x)

    def empty(self) -> "bool":
        r"""empty(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t_empty(self)

    def size(self) -> "std::vector< void * >::size_type":
        r"""size(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t_size(self)

    def swap(self, v: "void_start_vector_t") -> "void":
        r"""swap(void_start_vector_t self, void_start_vector_t v)"""
        return _runtime_swig.void_start_vector_t_swap(self, v)

    def begin(self) -> "std::vector< void * >::iterator":
        r"""begin(void_start_vector_t self) -> std::vector< void * >::iterator"""
        return _runtime_swig.void_start_vector_t_begin(self)

    def end(self) -> "std::vector< void * >::iterator":
        r"""end(void_start_vector_t self) -> std::vector< void * >::iterator"""
        return _runtime_swig.void_start_vector_t_end(self)

    def rbegin(self) -> "std::vector< void * >::reverse_iterator":
        r"""rbegin(void_start_vector_t self) -> std::vector< void * >::reverse_iterator"""
        return _runtime_swig.void_start_vector_t_rbegin(self)

    def rend(self) -> "std::vector< void * >::reverse_iterator":
        r"""rend(void_start_vector_t self) -> std::vector< void * >::reverse_iterator"""
        return _runtime_swig.void_start_vector_t_rend(self)

    def clear(self) -> "void":
        r"""clear(void_start_vector_t self)"""
        return _runtime_swig.void_start_vector_t_clear(self)

    def get_allocator(self) -> "std::vector< void * >::allocator_type":
        r"""get_allocator(void_start_vector_t self) -> std::vector< void * >::allocator_type"""
        return _runtime_swig.void_start_vector_t_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(void_start_vector_t self)"""
        return _runtime_swig.void_start_vector_t_pop_back(self)

    def erase(self, *args) -> "std::vector< void * >::iterator":
        r"""
        erase(void_start_vector_t self, std::vector< void * >::iterator pos) -> std::vector< void * >::iterator
        erase(void_start_vector_t self, std::vector< void * >::iterator first, std::vector< void * >::iterator last) -> std::vector< void * >::iterator
        """
        return _runtime_swig.void_start_vector_t_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(void_start_vector_t self) -> void_start_vector_t
        __init__(void_start_vector_t self, void_start_vector_t other) -> void_start_vector_t
        __init__(void_start_vector_t self, std::vector< void * >::size_type size) -> void_start_vector_t
        __init__(void_start_vector_t self, std::vector< void * >::size_type size, std::vector< void * >::value_type value) -> void_start_vector_t
        """
        _runtime_swig.void_start_vector_t_swiginit(self, _runtime_swig.new_void_start_vector_t(*args))

    def push_back(self, x: "std::vector< void * >::value_type") -> "void":
        r"""push_back(void_start_vector_t self, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_push_back(self, x)

    def front(self) -> "std::vector< void * >::value_type":
        r"""front(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_front(self)

    def back(self) -> "std::vector< void * >::value_type":
        r"""back(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_back(self)

    def assign(self, n: "std::vector< void * >::size_type", x: "std::vector< void * >::value_type") -> "void":
        r"""assign(void_start_vector_t self, std::vector< void * >::size_type n, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(void_start_vector_t self, std::vector< void * >::size_type new_size)
        resize(void_start_vector_t self, std::vector< void * >::size_type new_size, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(void_start_vector_t self, std::vector< void * >::iterator pos, std::vector< void * >::value_type x) -> std::vector< void * >::iterator
        insert(void_start_vector_t self, std::vector< void * >::iterator pos, std::vector< void * >::size_type n, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t_insert(self, *args)

    def reserve(self, n: "std::vector< void * >::size_type") -> "void":
        r"""reserve(void_start_vector_t self, std::vector< void * >::size_type n)"""
        return _runtime_swig.void_start_vector_t_reserve(self, n)

    def capacity(self) -> "std::vector< void * >::size_type":
        r"""capacity(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t_capacity(self)
    __swig_destroy__ = _runtime_swig.delete_void_start_vector_t

# Register void_start_vector_t in _runtime_swig:
_runtime_swig.void_start_vector_t_swigregister(void_start_vector_t)

GR_BLOCK_GW_WORK_GENERAL = _runtime_swig.GR_BLOCK_GW_WORK_GENERAL

GR_BLOCK_GW_WORK_SYNC = _runtime_swig.GR_BLOCK_GW_WORK_SYNC

GR_BLOCK_GW_WORK_DECIM = _runtime_swig.GR_BLOCK_GW_WORK_DECIM

GR_BLOCK_GW_WORK_INTERP = _runtime_swig.GR_BLOCK_GW_WORK_INTERP

WORK_CALLED_PRODUCE = _runtime_swig.WORK_CALLED_PRODUCE

WORK_DONE = _runtime_swig.WORK_DONE

TPP_DONT = _runtime_swig.TPP_DONT

TPP_ALL_TO_ALL = _runtime_swig.TPP_ALL_TO_ALL

TPP_ONE_TO_ONE = _runtime_swig.TPP_ONE_TO_ONE

TPP_CUSTOM = _runtime_swig.TPP_CUSTOM

class block_gw_message_type(object):
    r"""Proxy of C++ gr::block_gw_message_type class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ACTION_GENERAL_WORK = _runtime_swig.block_gw_message_type_ACTION_GENERAL_WORK
    
    ACTION_WORK = _runtime_swig.block_gw_message_type_ACTION_WORK
    
    ACTION_FORECAST = _runtime_swig.block_gw_message_type_ACTION_FORECAST
    
    ACTION_START = _runtime_swig.block_gw_message_type_ACTION_START
    
    ACTION_STOP = _runtime_swig.block_gw_message_type_ACTION_STOP
    
    action = property(_runtime_swig.block_gw_message_type_action_get, _runtime_swig.block_gw_message_type_action_set, doc=r"""action : gr::block_gw_message_type::action_type""")
    general_work_args_noutput_items = property(_runtime_swig.block_gw_message_type_general_work_args_noutput_items_get, _runtime_swig.block_gw_message_type_general_work_args_noutput_items_set, doc=r"""general_work_args_noutput_items : int""")
    general_work_args_ninput_items = property(_runtime_swig.block_gw_message_type_general_work_args_ninput_items_get, _runtime_swig.block_gw_message_type_general_work_args_ninput_items_set, doc=r"""general_work_args_ninput_items : std::vector<(int,std::allocator<(int)>)>""")
    general_work_args_input_items = property(_runtime_swig.block_gw_message_type_general_work_args_input_items_get, _runtime_swig.block_gw_message_type_general_work_args_input_items_set, doc=r"""general_work_args_input_items : std::vector<(p.void,std::allocator<(p.void)>)>""")
    general_work_args_output_items = property(_runtime_swig.block_gw_message_type_general_work_args_output_items_get, _runtime_swig.block_gw_message_type_general_work_args_output_items_set, doc=r"""general_work_args_output_items : std::vector<(p.void,std::allocator<(p.void)>)>""")
    general_work_args_return_value = property(_runtime_swig.block_gw_message_type_general_work_args_return_value_get, _runtime_swig.block_gw_message_type_general_work_args_return_value_set, doc=r"""general_work_args_return_value : int""")
    work_args_ninput_items = property(_runtime_swig.block_gw_message_type_work_args_ninput_items_get, _runtime_swig.block_gw_message_type_work_args_ninput_items_set, doc=r"""work_args_ninput_items : int""")
    work_args_noutput_items = property(_runtime_swig.block_gw_message_type_work_args_noutput_items_get, _runtime_swig.block_gw_message_type_work_args_noutput_items_set, doc=r"""work_args_noutput_items : int""")
    work_args_input_items = property(_runtime_swig.block_gw_message_type_work_args_input_items_get, _runtime_swig.block_gw_message_type_work_args_input_items_set, doc=r"""work_args_input_items : std::vector<(p.void,std::allocator<(p.void)>)>""")
    work_args_output_items = property(_runtime_swig.block_gw_message_type_work_args_output_items_get, _runtime_swig.block_gw_message_type_work_args_output_items_set, doc=r"""work_args_output_items : std::vector<(p.void,std::allocator<(p.void)>)>""")
    work_args_return_value = property(_runtime_swig.block_gw_message_type_work_args_return_value_get, _runtime_swig.block_gw_message_type_work_args_return_value_set, doc=r"""work_args_return_value : int""")
    forecast_args_noutput_items = property(_runtime_swig.block_gw_message_type_forecast_args_noutput_items_get, _runtime_swig.block_gw_message_type_forecast_args_noutput_items_set, doc=r"""forecast_args_noutput_items : int""")
    forecast_args_ninput_items_required = property(_runtime_swig.block_gw_message_type_forecast_args_ninput_items_required_get, _runtime_swig.block_gw_message_type_forecast_args_ninput_items_required_set, doc=r"""forecast_args_ninput_items_required : std::vector<(int,std::allocator<(int)>)>""")
    start_args_return_value = property(_runtime_swig.block_gw_message_type_start_args_return_value_get, _runtime_swig.block_gw_message_type_start_args_return_value_set, doc=r"""start_args_return_value : bool""")
    stop_args_return_value = property(_runtime_swig.block_gw_message_type_stop_args_return_value_get, _runtime_swig.block_gw_message_type_stop_args_return_value_set, doc=r"""stop_args_return_value : bool""")

    def __init__(self):
        r"""__init__(block_gw_message_type self) -> block_gw_message_type"""
        _runtime_swig.block_gw_message_type_swiginit(self, _runtime_swig.new_block_gw_message_type())
    __swig_destroy__ = _runtime_swig.delete_block_gw_message_type

# Register block_gw_message_type in _runtime_swig:
_runtime_swig.block_gw_message_type_swigregister(block_gw_message_type)

class block_gateway(block):
    r"""
    The gateway block which performs all the magic.


    The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

    Constructor Specific Documentation:

    Make a new gateway block.

    Args:
        handler : the swig director object with callback
        name : the name of the block (Ex: "Shirley")
        in_sig : the input signature for this block
        out_sig : the output signature for this block
        work_type : the type of block overload to implement
        factor : the decimation or interpolation factor
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def make(handler: "gr::feval_ll *", name: "std::string const &", in_sig: "io_signature_sptr", out_sig: "io_signature_sptr", work_type: "gr::block_gw_work_type const", factor: "unsigned int const") -> "gr::block_gateway::sptr":
        r"""
        make(gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr
        The gateway block which performs all the magic.


        The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

        Constructor Specific Documentation:

        Make a new gateway block.

        Args:
            handler : the swig director object with callback
            name : the name of the block (Ex: "Shirley")
            in_sig : the input signature for this block
            out_sig : the output signature for this block
            work_type : the type of block overload to implement
            factor : the decimation or interpolation factor
        """
        return _runtime_swig.block_gateway_make(handler, name, in_sig, out_sig, work_type, factor)

    def block_message(self) -> "gr::block_gw_message_type &":
        r"""
        block_message(block_gateway self) -> block_gw_message_type
        Provide access to the shared message object.
        """
        return _runtime_swig.block_gateway_block_message(self)

    def block__unique_id(self) -> "long":
        r"""block__unique_id(block_gateway self) -> long"""
        return _runtime_swig.block_gateway_block__unique_id(self)

    def block__name(self) -> "std::string":
        r"""block__name(block_gateway self) -> std::string"""
        return _runtime_swig.block_gateway_block__name(self)

    def block__history(self) -> "unsigned int":
        r"""block__history(block_gateway self) -> unsigned int"""
        return _runtime_swig.block_gateway_block__history(self)

    def block__set_history(self, history: "unsigned int") -> "void":
        r"""block__set_history(block_gateway self, unsigned int history)"""
        return _runtime_swig.block_gateway_block__set_history(self, history)

    def block__set_fixed_rate(self, fixed_rate: "bool") -> "void":
        r"""block__set_fixed_rate(block_gateway self, bool fixed_rate)"""
        return _runtime_swig.block_gateway_block__set_fixed_rate(self, fixed_rate)

    def block__fixed_rate(self) -> "bool":
        r"""block__fixed_rate(block_gateway self) -> bool"""
        return _runtime_swig.block_gateway_block__fixed_rate(self)

    def block__set_output_multiple(self, multiple: "int") -> "void":
        r"""block__set_output_multiple(block_gateway self, int multiple)"""
        return _runtime_swig.block_gateway_block__set_output_multiple(self, multiple)

    def block__set_min_output_buffer(self, *args) -> "void":
        r"""
        block__set_min_output_buffer(block_gateway self, int port, long size)
        block__set_min_output_buffer(block_gateway self, long size)
        """
        return _runtime_swig.block_gateway_block__set_min_output_buffer(self, *args)

    def block__output_multiple(self) -> "int":
        r"""block__output_multiple(block_gateway self) -> int"""
        return _runtime_swig.block_gateway_block__output_multiple(self)

    def block__consume(self, which_input: "int", how_many_items: "int") -> "void":
        r"""block__consume(block_gateway self, int which_input, int how_many_items)"""
        return _runtime_swig.block_gateway_block__consume(self, which_input, how_many_items)

    def block__consume_each(self, how_many_items: "int") -> "void":
        r"""block__consume_each(block_gateway self, int how_many_items)"""
        return _runtime_swig.block_gateway_block__consume_each(self, how_many_items)

    def block__produce(self, which_output: "int", how_many_items: "int") -> "void":
        r"""block__produce(block_gateway self, int which_output, int how_many_items)"""
        return _runtime_swig.block_gateway_block__produce(self, which_output, how_many_items)

    def block__set_inverse_relative_rate(self, inverse_relative_rate: "double") -> "void":
        r"""block__set_inverse_relative_rate(block_gateway self, double inverse_relative_rate)"""
        return _runtime_swig.block_gateway_block__set_inverse_relative_rate(self, inverse_relative_rate)

    def block__set_relative_rate(self, *args) -> "void":
        r"""
        block__set_relative_rate(block_gateway self, double relative_rate)
        block__set_relative_rate(block_gateway self, uint64_t interpolation, uint64_t decimation)
        """
        return _runtime_swig.block_gateway_block__set_relative_rate(self, *args)

    def block__relative_rate(self) -> "double":
        r"""block__relative_rate(block_gateway self) -> double"""
        return _runtime_swig.block_gateway_block__relative_rate(self)

    def block__relative_rate_i(self) -> "uint64_t":
        r"""block__relative_rate_i(block_gateway self) -> uint64_t"""
        return _runtime_swig.block_gateway_block__relative_rate_i(self)

    def block__relative_rate_d(self) -> "uint64_t":
        r"""block__relative_rate_d(block_gateway self) -> uint64_t"""
        return _runtime_swig.block_gateway_block__relative_rate_d(self)

    def block__nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""block__nitems_read(block_gateway self, unsigned int which_input) -> uint64_t"""
        return _runtime_swig.block_gateway_block__nitems_read(self, which_input)

    def block__nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""block__nitems_written(block_gateway self, unsigned int which_output) -> uint64_t"""
        return _runtime_swig.block_gateway_block__nitems_written(self, which_output)

    def block__tag_propagation_policy(self) -> "gr::block::tag_propagation_policy_t":
        r"""block__tag_propagation_policy(block_gateway self) -> gr::block::tag_propagation_policy_t"""
        return _runtime_swig.block_gateway_block__tag_propagation_policy(self)

    def block__set_tag_propagation_policy(self, p: "gr::block::tag_propagation_policy_t") -> "void":
        r"""block__set_tag_propagation_policy(block_gateway self, gr::block::tag_propagation_policy_t p)"""
        return _runtime_swig.block_gateway_block__set_tag_propagation_policy(self, p)

    def block__add_item_tag(self, *args) -> "void":
        r"""
        block__add_item_tag(block_gateway self, unsigned int which_output, tag_t tag)
        block__add_item_tag(block_gateway self, unsigned int which_output, uint64_t abs_offset, swig_pmt_ptr key, swig_pmt_ptr value, swig_pmt_ptr srcid=pmt::get_PMT_F())
        """
        return _runtime_swig.block_gateway_block__add_item_tag(self, *args)

    def block__get_tags_in_range(self, *args) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""
        block__get_tags_in_range(block_gateway self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end) -> tags_vector_t
        block__get_tags_in_range(block_gateway self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end, swig_pmt_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_block__get_tags_in_range(self, *args)

    def block__get_tags_in_window(self, *args) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""
        block__get_tags_in_window(block_gateway self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end) -> tags_vector_t
        block__get_tags_in_window(block_gateway self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end, swig_pmt_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_block__get_tags_in_window(self, *args)

    def block__message_port_register_in(self, port_id: "swig_pmt_ptr") -> "void":
        r"""block__message_port_register_in(block_gateway self, swig_pmt_ptr port_id)"""
        return _runtime_swig.block_gateway_block__message_port_register_in(self, port_id)

    def block__message_port_register_out(self, port_id: "swig_pmt_ptr") -> "void":
        r"""block__message_port_register_out(block_gateway self, swig_pmt_ptr port_id)"""
        return _runtime_swig.block_gateway_block__message_port_register_out(self, port_id)

    def block__message_port_pub(self, port_id: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""block__message_port_pub(block_gateway self, swig_pmt_ptr port_id, swig_pmt_ptr msg)"""
        return _runtime_swig.block_gateway_block__message_port_pub(self, port_id, msg)

    def block__message_port_sub(self, port_id: "swig_pmt_ptr", target: "swig_pmt_ptr") -> "void":
        r"""block__message_port_sub(block_gateway self, swig_pmt_ptr port_id, swig_pmt_ptr target)"""
        return _runtime_swig.block_gateway_block__message_port_sub(self, port_id, target)

    def block__message_port_unsub(self, port_id: "swig_pmt_ptr", target: "swig_pmt_ptr") -> "void":
        r"""block__message_port_unsub(block_gateway self, swig_pmt_ptr port_id, swig_pmt_ptr target)"""
        return _runtime_swig.block_gateway_block__message_port_unsub(self, port_id, target)

    def block__message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""block__message_subscribers(block_gateway self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_block__message_subscribers(self, which_port)

    def block__message_ports_in(self) -> "pmt::pmt_t":
        r"""block__message_ports_in(block_gateway self) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_block__message_ports_in(self)

    def block__message_ports_out(self) -> "pmt::pmt_t":
        r"""block__message_ports_out(block_gateway self) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_block__message_ports_out(self)

    def set_msg_handler_feval(self, which_port: "swig_pmt_ptr", msg_handler: "gr::feval_p *") -> "void":
        r"""set_msg_handler_feval(block_gateway self, swig_pmt_ptr which_port, gr::feval_p * msg_handler)"""
        return _runtime_swig.block_gateway_set_msg_handler_feval(self, which_port, msg_handler)
    __swig_destroy__ = _runtime_swig.delete_block_gateway

# Register block_gateway in _runtime_swig:
_runtime_swig.block_gateway_swigregister(block_gateway)

def block_gateway_make(handler: "gr::feval_ll *", name: "std::string const &", in_sig: "io_signature_sptr", out_sig: "io_signature_sptr", work_type: "gr::block_gw_work_type const", factor: "unsigned int const") -> "gr::block_gateway::sptr":
    r"""
    block_gateway_make(gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr
    The gateway block which performs all the magic.


    The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

    Constructor Specific Documentation:

    Make a new gateway block.

    Args:
        handler : the swig director object with callback
        name : the name of the block (Ex: "Shirley")
        in_sig : the input signature for this block
        out_sig : the output signature for this block
        work_type : the type of block overload to implement
        factor : the decimation or interpolation factor
    """
    return _runtime_swig.block_gateway_make(handler, name, in_sig, out_sig, work_type, factor)

class block_gateway_sptr(object):
    r"""Proxy of C++ boost::shared_ptr< gr::block_gateway > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(block_gateway_sptr self) -> block_gateway_sptr
        __init__(block_gateway_sptr self, block_gateway p) -> block_gateway_sptr
        """
        _runtime_swig.block_gateway_sptr_swiginit(self, _runtime_swig.new_block_gateway_sptr(*args))

    def __deref__(self) -> "gr::block_gateway *":
        r"""__deref__(block_gateway_sptr self) -> block_gateway"""
        return _runtime_swig.block_gateway_sptr___deref__(self)
    __swig_destroy__ = _runtime_swig.delete_block_gateway_sptr

    def make(self, handler: "gr::feval_ll *", name: "std::string const &", in_sig: "io_signature_sptr", out_sig: "io_signature_sptr", work_type: "gr::block_gw_work_type const", factor: "unsigned int const") -> "gr::block_gateway::sptr":
        r"""
        make(block_gateway_sptr self, gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr
        The gateway block which performs all the magic.


        The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

        Constructor Specific Documentation:

        Make a new gateway block.

        Args:
            handler : the swig director object with callback
            name : the name of the block (Ex: "Shirley")
            in_sig : the input signature for this block
            out_sig : the output signature for this block
            work_type : the type of block overload to implement
            factor : the decimation or interpolation factor
        """
        return _runtime_swig.block_gateway_sptr_make(self, handler, name, in_sig, out_sig, work_type, factor)

    def block_message(self) -> "gr::block_gw_message_type &":
        r"""
        block_message(block_gateway_sptr self) -> block_gw_message_type
        Provide access to the shared message object.
        """
        return _runtime_swig.block_gateway_sptr_block_message(self)

    def block__unique_id(self) -> "long":
        r"""block__unique_id(block_gateway_sptr self) -> long"""
        return _runtime_swig.block_gateway_sptr_block__unique_id(self)

    def block__name(self) -> "std::string":
        r"""block__name(block_gateway_sptr self) -> std::string"""
        return _runtime_swig.block_gateway_sptr_block__name(self)

    def block__history(self) -> "unsigned int":
        r"""block__history(block_gateway_sptr self) -> unsigned int"""
        return _runtime_swig.block_gateway_sptr_block__history(self)

    def block__set_history(self, history: "unsigned int") -> "void":
        r"""block__set_history(block_gateway_sptr self, unsigned int history)"""
        return _runtime_swig.block_gateway_sptr_block__set_history(self, history)

    def block__set_fixed_rate(self, fixed_rate: "bool") -> "void":
        r"""block__set_fixed_rate(block_gateway_sptr self, bool fixed_rate)"""
        return _runtime_swig.block_gateway_sptr_block__set_fixed_rate(self, fixed_rate)

    def block__fixed_rate(self) -> "bool":
        r"""block__fixed_rate(block_gateway_sptr self) -> bool"""
        return _runtime_swig.block_gateway_sptr_block__fixed_rate(self)

    def block__set_output_multiple(self, multiple: "int") -> "void":
        r"""block__set_output_multiple(block_gateway_sptr self, int multiple)"""
        return _runtime_swig.block_gateway_sptr_block__set_output_multiple(self, multiple)

    def block__set_min_output_buffer(self, *args) -> "void":
        r"""
        block__set_min_output_buffer(block_gateway_sptr self, int port, long size)
        block__set_min_output_buffer(block_gateway_sptr self, long size)
        """
        return _runtime_swig.block_gateway_sptr_block__set_min_output_buffer(self, *args)

    def block__output_multiple(self) -> "int":
        r"""block__output_multiple(block_gateway_sptr self) -> int"""
        return _runtime_swig.block_gateway_sptr_block__output_multiple(self)

    def block__consume(self, which_input: "int", how_many_items: "int") -> "void":
        r"""block__consume(block_gateway_sptr self, int which_input, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__consume(self, which_input, how_many_items)

    def block__consume_each(self, how_many_items: "int") -> "void":
        r"""block__consume_each(block_gateway_sptr self, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__consume_each(self, how_many_items)

    def block__produce(self, which_output: "int", how_many_items: "int") -> "void":
        r"""block__produce(block_gateway_sptr self, int which_output, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__produce(self, which_output, how_many_items)

    def block__set_relative_rate(self, *args) -> "void":
        r"""
        block__set_relative_rate(block_gateway_sptr self, double relative_rate)
        block__set_relative_rate(block_gateway_sptr self, uint64_t interpolation, uint64_t decimation)
        """
        return _runtime_swig.block_gateway_sptr_block__set_relative_rate(self, *args)

    def block__set_inverse_relative_rate(self, inverse_relative_rate: "double") -> "void":
        r"""block__set_inverse_relative_rate(block_gateway_sptr self, double inverse_relative_rate)"""
        return _runtime_swig.block_gateway_sptr_block__set_inverse_relative_rate(self, inverse_relative_rate)

    def block__relative_rate(self) -> "double":
        r"""block__relative_rate(block_gateway_sptr self) -> double"""
        return _runtime_swig.block_gateway_sptr_block__relative_rate(self)

    def block__relative_rate_i(self) -> "uint64_t":
        r"""block__relative_rate_i(block_gateway_sptr self) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__relative_rate_i(self)

    def block__relative_rate_d(self) -> "uint64_t":
        r"""block__relative_rate_d(block_gateway_sptr self) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__relative_rate_d(self)

    def block__nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""block__nitems_read(block_gateway_sptr self, unsigned int which_input) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__nitems_read(self, which_input)

    def block__nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""block__nitems_written(block_gateway_sptr self, unsigned int which_output) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__nitems_written(self, which_output)

    def block__tag_propagation_policy(self) -> "gr::block::tag_propagation_policy_t":
        r"""block__tag_propagation_policy(block_gateway_sptr self) -> gr::block::tag_propagation_policy_t"""
        return _runtime_swig.block_gateway_sptr_block__tag_propagation_policy(self)

    def block__set_tag_propagation_policy(self, p: "gr::block::tag_propagation_policy_t") -> "void":
        r"""block__set_tag_propagation_policy(block_gateway_sptr self, gr::block::tag_propagation_policy_t p)"""
        return _runtime_swig.block_gateway_sptr_block__set_tag_propagation_policy(self, p)

    def block__add_item_tag(self, *args) -> "void":
        r"""
        block__add_item_tag(block_gateway_sptr self, unsigned int which_output, tag_t tag)
        block__add_item_tag(block_gateway_sptr self, unsigned int which_output, uint64_t abs_offset, swig_pmt_ptr key, swig_pmt_ptr value, swig_pmt_ptr srcid=pmt::get_PMT_F())
        """
        return _runtime_swig.block_gateway_sptr_block__add_item_tag(self, *args)

    def block__get_tags_in_range(self, *args) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""
        block__get_tags_in_range(block_gateway_sptr self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end) -> tags_vector_t
        block__get_tags_in_range(block_gateway_sptr self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end, swig_pmt_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_sptr_block__get_tags_in_range(self, *args)

    def block__get_tags_in_window(self, *args) -> "std::vector< gr::tag_t,std::allocator< gr::tag_t > >":
        r"""
        block__get_tags_in_window(block_gateway_sptr self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end) -> tags_vector_t
        block__get_tags_in_window(block_gateway_sptr self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end, swig_pmt_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_sptr_block__get_tags_in_window(self, *args)

    def block__message_port_register_in(self, port_id: "swig_pmt_ptr") -> "void":
        r"""block__message_port_register_in(block_gateway_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_register_in(self, port_id)

    def block__message_port_register_out(self, port_id: "swig_pmt_ptr") -> "void":
        r"""block__message_port_register_out(block_gateway_sptr self, swig_pmt_ptr port_id)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_register_out(self, port_id)

    def block__message_port_pub(self, port_id: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""block__message_port_pub(block_gateway_sptr self, swig_pmt_ptr port_id, swig_pmt_ptr msg)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_pub(self, port_id, msg)

    def block__message_port_sub(self, port_id: "swig_pmt_ptr", target: "swig_pmt_ptr") -> "void":
        r"""block__message_port_sub(block_gateway_sptr self, swig_pmt_ptr port_id, swig_pmt_ptr target)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_sub(self, port_id, target)

    def block__message_port_unsub(self, port_id: "swig_pmt_ptr", target: "swig_pmt_ptr") -> "void":
        r"""block__message_port_unsub(block_gateway_sptr self, swig_pmt_ptr port_id, swig_pmt_ptr target)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_unsub(self, port_id, target)

    def block__message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""block__message_subscribers(block_gateway_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_subscribers(self, which_port)

    def block__message_ports_in(self) -> "pmt::pmt_t":
        r"""block__message_ports_in(block_gateway_sptr self) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_ports_in(self)

    def block__message_ports_out(self) -> "pmt::pmt_t":
        r"""block__message_ports_out(block_gateway_sptr self) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_ports_out(self)

    def set_msg_handler_feval(self, which_port: "swig_pmt_ptr", msg_handler: "gr::feval_p *") -> "void":
        r"""set_msg_handler_feval(block_gateway_sptr self, swig_pmt_ptr which_port, gr::feval_p * msg_handler)"""
        return _runtime_swig.block_gateway_sptr_set_msg_handler_feval(self, which_port, msg_handler)

    def history(self) -> "unsigned int":
        r"""
        history(block_gateway_sptr self) -> unsigned int
        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_gateway_sptr_history(self)

    def declare_sample_delay(self, *args) -> "void":
        r"""
        declare_sample_delay(block_gateway_sptr self, int which, int delay)
        declare_sample_delay(block_gateway_sptr self, unsigned int delay)
        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.


        This does not actively set the delay; it just tells the scheduler what the delay is.


        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_gateway_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, which: "int") -> "unsigned int":
        r"""
        sample_delay(block_gateway_sptr self, int which) -> unsigned int
        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_gateway_sptr_sample_delay(self, which)

    def set_output_multiple(self, multiple: "int") -> "void":
        r"""
        set_output_multiple(block_gateway_sptr self, int multiple)
        Constrain the noutput_items argument passed to forecast and general_work.

        set_output_multiple causes the scheduler to ensure that the noutput_items argument passed to forecast and general_work will be an integer multiple of
        """
        return _runtime_swig.block_gateway_sptr_set_output_multiple(self, multiple)

    def output_multiple(self) -> "int":
        r"""output_multiple(block_gateway_sptr self) -> int"""
        return _runtime_swig.block_gateway_sptr_output_multiple(self)

    def relative_rate(self) -> "double":
        r"""
        relative_rate(block_gateway_sptr self) -> double
        return the approximate output rate / input rate
        """
        return _runtime_swig.block_gateway_sptr_relative_rate(self)

    def relative_rate_i(self) -> "uint64_t":
        r"""
        relative_rate_i(block_gateway_sptr self) -> uint64_t
        return the numerator, or interpolation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_gateway_sptr_relative_rate_i(self)

    def relative_rate_d(self) -> "uint64_t":
        r"""
        relative_rate_d(block_gateway_sptr self) -> uint64_t
        return the denominator, or decimation rate, of the approximate output rate / input rate
        """
        return _runtime_swig.block_gateway_sptr_relative_rate_d(self)

    def start(self) -> "bool":
        r"""
        start(block_gateway_sptr self) -> bool
        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_gateway_sptr_start(self)

    def stop(self) -> "bool":
        r"""
        stop(block_gateway_sptr self) -> bool
        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_gateway_sptr_stop(self)

    def nitems_read(self, which_input: "unsigned int") -> "uint64_t":
        r"""
        nitems_read(block_gateway_sptr self, unsigned int which_input) -> uint64_t
        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_gateway_sptr_nitems_read(self, which_input)

    def nitems_written(self, which_output: "unsigned int") -> "uint64_t":
        r"""
        nitems_written(block_gateway_sptr self, unsigned int which_output) -> uint64_t
        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_gateway_sptr_nitems_written(self, which_output)

    def set_log_level(self, level: "std::string") -> "void":
        r"""
        set_log_level(block_gateway_sptr self, std::string level)
        Set the logger's output level.

        Sets the level of the logger. This takes a string that is translated to the standard levels and can be (case insensitive):
        """
        return _runtime_swig.block_gateway_sptr_set_log_level(self, level)

    def log_level(self) -> "std::string":
        r"""
        log_level(block_gateway_sptr self) -> std::string
        Get the logger's output level.
        """
        return _runtime_swig.block_gateway_sptr_log_level(self)

    def max_noutput_items(self) -> "int":
        r"""
        max_noutput_items(block_gateway_sptr self) -> int
        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, m: "int") -> "void":
        r"""
        set_max_noutput_items(block_gateway_sptr self, int m)
        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_set_max_noutput_items(self, m)

    def unset_max_noutput_items(self) -> "void":
        r"""
        unset_max_noutput_items(block_gateway_sptr self)
        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.


        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_gateway_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self) -> "bool":
        r"""
        is_set_max_noutput_items(block_gateway_sptr self) -> bool
        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, m: "int") -> "void":
        r"""
        set_min_noutput_items(block_gateway_sptr self, int m)
        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_set_min_noutput_items(self, m)

    def min_noutput_items(self) -> "int":
        r"""
        min_noutput_items(block_gateway_sptr self) -> int
        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_gateway_sptr_min_noutput_items(self)

    def max_output_buffer(self, i: "int") -> "long":
        r"""
        max_output_buffer(block_gateway_sptr self, int i) -> long
        Returns max buffer size on output port .
        """
        return _runtime_swig.block_gateway_sptr_max_output_buffer(self, i)

    def set_max_output_buffer(self, *args) -> "void":
        r"""
        set_max_output_buffer(block_gateway_sptr self, long max_output_buffer)
        set_max_output_buffer(block_gateway_sptr self, int port, long max_output_buffer)
        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_gateway_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, i: "int") -> "long":
        r"""
        min_output_buffer(block_gateway_sptr self, int i) -> long
        Returns min buffer size on output port .
        """
        return _runtime_swig.block_gateway_sptr_min_output_buffer(self, i)

    def set_min_output_buffer(self, *args) -> "void":
        r"""
        set_min_output_buffer(block_gateway_sptr self, long min_output_buffer)
        set_min_output_buffer(block_gateway_sptr self, int port, long min_output_buffer)
        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.


        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_gateway_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self) -> "float":
        r"""
        pc_noutput_items(block_gateway_sptr self) -> float
        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self) -> "float":
        r"""
        pc_noutput_items_avg(block_gateway_sptr self) -> float
        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self) -> "float":
        r"""
        pc_noutput_items_var(block_gateway_sptr self) -> float
        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self) -> "float":
        r"""
        pc_nproduced(block_gateway_sptr self) -> float
        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self) -> "float":
        r"""
        pc_nproduced_avg(block_gateway_sptr self) -> float
        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self) -> "float":
        r"""
        pc_nproduced_var(block_gateway_sptr self) -> float
        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_avg(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full_avg(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_input_buffers_full_var(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full_var(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets instantaneous fullness of  output buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_avg(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full_avg(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets average fullness of  output buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args) -> "std::vector< float,std::allocator< float > >":
        r"""
        pc_output_buffers_full_var(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full_var(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >
        Gets variance of fullness of  output buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self) -> "float":
        r"""
        pc_work_time(block_gateway_sptr self) -> float
        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time(self)

    def pc_work_time_avg(self) -> "float":
        r"""
        pc_work_time_avg(block_gateway_sptr self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self) -> "float":
        r"""
        pc_work_time_var(block_gateway_sptr self) -> float
        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_var(self)

    def pc_work_time_total(self) -> "float":
        r"""
        pc_work_time_total(block_gateway_sptr self) -> float
        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self) -> "float":
        r"""
        pc_throughput_avg(block_gateway_sptr self) -> float
        Gets average throughput.
        """
        return _runtime_swig.block_gateway_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, mask: "std::vector< int,std::allocator< int > > const &") -> "void":
        r"""
        set_processor_affinity(block_gateway_sptr self, std::vector< int,std::allocator< int > > const & mask)
        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_gateway_sptr_set_processor_affinity(self, mask)

    def unset_processor_affinity(self) -> "void":
        r"""
        unset_processor_affinity(block_gateway_sptr self)
        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_gateway_sptr_unset_processor_affinity(self)

    def processor_affinity(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        processor_affinity(block_gateway_sptr self) -> std::vector< int,std::allocator< int > >
        Get the current processor affinity.
        """
        return _runtime_swig.block_gateway_sptr_processor_affinity(self)

    def active_thread_priority(self) -> "int":
        r"""
        active_thread_priority(block_gateway_sptr self) -> int
        Get the current thread priority in use.
        """
        return _runtime_swig.block_gateway_sptr_active_thread_priority(self)

    def thread_priority(self) -> "int":
        r"""
        thread_priority(block_gateway_sptr self) -> int
        Get the current thread priority stored.
        """
        return _runtime_swig.block_gateway_sptr_thread_priority(self)

    def set_thread_priority(self, priority: "int") -> "int":
        r"""
        set_thread_priority(block_gateway_sptr self, int priority) -> int
        Set the current thread priority.
        """
        return _runtime_swig.block_gateway_sptr_set_thread_priority(self, priority)

    def name(self) -> "std::string":
        r"""
        name(block_gateway_sptr self) -> std::string
        The name of the block
        """
        return _runtime_swig.block_gateway_sptr_name(self)

    def symbol_name(self) -> "std::string":
        r"""
        symbol_name(block_gateway_sptr self) -> std::string
        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.block_gateway_sptr_symbol_name(self)

    def input_signature(self) -> "gr::io_signature::sptr":
        r"""input_signature(block_gateway_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_gateway_sptr_input_signature(self)

    def output_signature(self) -> "gr::io_signature::sptr":
        r"""output_signature(block_gateway_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_gateway_sptr_output_signature(self)

    def unique_id(self) -> "long":
        r"""unique_id(block_gateway_sptr self) -> long"""
        return _runtime_swig.block_gateway_sptr_unique_id(self)

    def to_basic_block(self) -> "gr::basic_block_sptr":
        r"""to_basic_block(block_gateway_sptr self) -> basic_block_sptr"""
        return _runtime_swig.block_gateway_sptr_to_basic_block(self)

    def check_topology(self, ninputs: "int", noutputs: "int") -> "bool":
        r"""
        check_topology(block_gateway_sptr self, int ninputs, int noutputs) -> bool
        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.block_gateway_sptr_check_topology(self, ninputs, noutputs)

    def alias(self) -> "std::string":
        r"""
        alias(block_gateway_sptr self) -> std::string
        Returns the block's alias as a string.
        """
        return _runtime_swig.block_gateway_sptr_alias(self)

    def set_block_alias(self, name: "std::string") -> "void":
        r"""
        set_block_alias(block_gateway_sptr self, std::string name)
        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.block_gateway_sptr_set_block_alias(self, name)

    def _post(self, which_port: "swig_pmt_ptr", msg: "swig_pmt_ptr") -> "void":
        r"""
        _post(block_gateway_sptr self, swig_pmt_ptr which_port, swig_pmt_ptr msg)
        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.block_gateway_sptr__post(self, which_port, msg)

    def message_ports_in(self) -> "pmt::pmt_t":
        r"""
        message_ports_in(block_gateway_sptr self) -> swig_pmt_ptr
        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_gateway_sptr_message_ports_in(self)

    def message_ports_out(self) -> "pmt::pmt_t":
        r"""
        message_ports_out(block_gateway_sptr self) -> swig_pmt_ptr
        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_gateway_sptr_message_ports_out(self)

    def message_subscribers(self, which_port: "swig_pmt_ptr") -> "pmt::pmt_t":
        r"""message_subscribers(block_gateway_sptr self, swig_pmt_ptr which_port) -> swig_pmt_ptr"""
        return _runtime_swig.block_gateway_sptr_message_subscribers(self, which_port)

# Register block_gateway_sptr in _runtime_swig:
_runtime_swig.block_gateway_sptr_swigregister(block_gateway_sptr)


block_gateway_sptr.__repr__ = lambda self: "<block_gateway>"
block_gateway = block_gateway.make;


def logger_config(config_filename: "std::string const", watch_period: "unsigned int"=0) -> "void":
    r"""
    logger_config(std::string const config_filename, unsigned int watch_period=0)
    Function to call configuration macro from python. Note: Configuration is only updated if filename or watch_period has changed.
    """
    return _runtime_swig.logger_config(config_filename, watch_period)

def logger_get_names() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    logger_get_names() -> std::vector< std::string,std::allocator< std::string > >
    Function to return logger names to python.
    """
    return _runtime_swig.logger_get_names()

def logger_reset_config() -> "void":
    r"""
    logger_reset_config()
    Function to reset logger configuration from python.
    """
    return _runtime_swig.logger_reset_config()
class logger(object):
    r"""Logger class for referencing loggers in python. Not needed in C++ (use macros) Wraps and manipulates loggers for python as python has no macros."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, logger_name: "std::string"):
        r"""
        __init__(logger self, std::string logger_name) -> logger
        constructor Provide name of logger to associate with this class
        """
        _runtime_swig.logger_swiginit(self, _runtime_swig.new_logger(logger_name))

    def set_level(self, level: "std::string") -> "void":
        r"""
        set_level(logger self, std::string level)
        inline function, wrapper to set the logger level
        """
        return _runtime_swig.logger_set_level(self, level)

    def get_level(self, level: "std::string &") -> "void":
        r"""
        get_level(logger self, std::string & level)
        inline function, wrapper to get the logger level
        """
        return _runtime_swig.logger_get_level(self, level)

    def debug(self, msg: "std::string") -> "void":
        r"""
        debug(logger self, std::string msg)
        inline function, wrapper for LOG4CPP_DEBUG for DEBUG message
        """
        return _runtime_swig.logger_debug(self, msg)

    def info(self, msg: "std::string") -> "void":
        r"""
        info(logger self, std::string msg)
        inline function, wrapper for LOG4CPP_INFO for INFO message
        """
        return _runtime_swig.logger_info(self, msg)

    def notice(self, msg: "std::string") -> "void":
        r"""
        notice(logger self, std::string msg)
        inline function, wrapper for NOTICE message
        """
        return _runtime_swig.logger_notice(self, msg)

    def warn(self, msg: "std::string") -> "void":
        r"""
        warn(logger self, std::string msg)
        inline function, wrapper for LOG4CPP_WARN for WARN message
        """
        return _runtime_swig.logger_warn(self, msg)

    def error(self, msg: "std::string") -> "void":
        r"""
        error(logger self, std::string msg)
        inline function, wrapper for LOG4CPP_ERROR for ERROR message
        """
        return _runtime_swig.logger_error(self, msg)

    def crit(self, msg: "std::string") -> "void":
        r"""
        crit(logger self, std::string msg)
        inline function, wrapper for NOTICE message
        """
        return _runtime_swig.logger_crit(self, msg)

    def alert(self, msg: "std::string") -> "void":
        r"""
        alert(logger self, std::string msg)
        inline function, wrapper for ALERT message
        """
        return _runtime_swig.logger_alert(self, msg)

    def fatal(self, msg: "std::string") -> "void":
        r"""
        fatal(logger self, std::string msg)
        inline function, wrapper for FATAL message
        """
        return _runtime_swig.logger_fatal(self, msg)

    def emerg(self, msg: "std::string") -> "void":
        r"""
        emerg(logger self, std::string msg)
        inline function, wrapper for EMERG message
        """
        return _runtime_swig.logger_emerg(self, msg)

    def errorIF(self, cond: "bool", msg: "std::string") -> "void":
        r"""
        errorIF(logger self, bool cond, std::string msg)
        inline function, wrapper for LOG4CPP_ASSERT for conditional ERROR message
        """
        return _runtime_swig.logger_errorIF(self, cond, msg)

    def log_assert(self, cond: "bool", msg: "std::string") -> "void":
        r"""
        log_assert(logger self, bool cond, std::string msg)
        inline function, wrapper for LOG4CPP_ASSERT for conditional ERROR message
        """
        return _runtime_swig.logger_log_assert(self, cond, msg)

    def add_console_appender(self, target: "std::string", pattern: "std::string") -> "void":
        r"""
        add_console_appender(logger self, std::string target, std::string pattern)
        inline function, Method to add console appender to logger
        """
        return _runtime_swig.logger_add_console_appender(self, target, pattern)

    def add_file_appender(self, filename: "std::string", append: "bool", pattern: "std::string") -> "void":
        r"""
        add_file_appender(logger self, std::string filename, bool append, std::string pattern)
        inline function, Method to add file appender to logger
        """
        return _runtime_swig.logger_add_file_appender(self, filename, append, pattern)

    def add_rollingfile_appender(self, filename: "std::string", filesize: "size_t", bkup_index: "int", append: "bool", mode: "mode_t", pattern: "std::string") -> "void":
        r"""
        add_rollingfile_appender(logger self, std::string filename, size_t filesize, int bkup_index, bool append, mode_t mode, std::string pattern)
        inline function, Method to add rolling file appender to logger
        """
        return _runtime_swig.logger_add_rollingfile_appender(self, filename, filesize, bkup_index, append, mode, pattern)
    __swig_destroy__ = _runtime_swig.delete_logger

# Register logger in _runtime_swig:
_runtime_swig.logger_swigregister(logger)

RPC_PRIVLVL_ALL = _runtime_swig.RPC_PRIVLVL_ALL

RPC_PRIVLVL_MIN = _runtime_swig.RPC_PRIVLVL_MIN

RPC_PRIVLVL_NONE = _runtime_swig.RPC_PRIVLVL_NONE

KNOBBOOL = _runtime_swig.KNOBBOOL

KNOBCHAR = _runtime_swig.KNOBCHAR

KNOBINT = _runtime_swig.KNOBINT

KNOBFLOAT = _runtime_swig.KNOBFLOAT

KNOBDOUBLE = _runtime_swig.KNOBDOUBLE

KNOBSTRING = _runtime_swig.KNOBSTRING

KNOBLONG = _runtime_swig.KNOBLONG

KNOBVECBOOL = _runtime_swig.KNOBVECBOOL

KNOBCOMPLEX = _runtime_swig.KNOBCOMPLEX

KNOBCOMPLEXD = _runtime_swig.KNOBCOMPLEXD

KNOBVECCHAR = _runtime_swig.KNOBVECCHAR

KNOBVECINT = _runtime_swig.KNOBVECINT

KNOBVECFLOAT = _runtime_swig.KNOBVECFLOAT

KNOBVECDOUBLE = _runtime_swig.KNOBVECDOUBLE

KNOBVECSTRING = _runtime_swig.KNOBVECSTRING

KNOBVECLONG = _runtime_swig.KNOBVECLONG

class rpcserver_booter_base(object):
    r"""Proxy of C++ rpcserver_booter_base class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_rpcserver_booter_base

    def i(self) -> "rpcserver_base *":
        r"""i(rpcserver_booter_base self) -> rpcserver_base *"""
        return _runtime_swig.rpcserver_booter_base_i(self)

    def endpoints(self) -> "std::vector< std::string,std::allocator< std::string > > const":
        r"""endpoints(rpcserver_booter_base self) -> std::vector< std::string,std::allocator< std::string > > const"""
        return _runtime_swig.rpcserver_booter_base_endpoints(self)

    def type(self) -> "std::string const &":
        r"""type(rpcserver_booter_base self) -> std::string const &"""
        return _runtime_swig.rpcserver_booter_base_type(self)

# Register rpcserver_booter_base in _runtime_swig:
_runtime_swig.rpcserver_booter_base_swigregister(rpcserver_booter_base)
cvar = _runtime_swig.cvar
DISPNULL = cvar.DISPNULL
DISPTIME = cvar.DISPTIME
DISPXY = cvar.DISPXY
DISPPSD = cvar.DISPPSD
DISPSPEC = cvar.DISPSPEC
DISPRAST = cvar.DISPRAST
DISPOPTCPLX = cvar.DISPOPTCPLX
DISPOPTLOG = cvar.DISPOPTLOG
DISPOPTSTEM = cvar.DISPOPTSTEM
DISPOPTSTRIP = cvar.DISPOPTSTRIP
DISPOPTSCATTER = cvar.DISPOPTSCATTER

class rpcserver_booter_aggregator(rpcserver_booter_base):
    r"""Proxy of C++ rpcserver_booter_aggregator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(rpcserver_booter_aggregator self) -> rpcserver_booter_aggregator"""
        _runtime_swig.rpcserver_booter_aggregator_swiginit(self, _runtime_swig.new_rpcserver_booter_aggregator())
    __swig_destroy__ = _runtime_swig.delete_rpcserver_booter_aggregator

    def registeredServers(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        r"""registeredServers(rpcserver_booter_aggregator self) -> std::vector< std::string,std::allocator< std::string > > const &"""
        return _runtime_swig.rpcserver_booter_aggregator_registeredServers(self)

# Register rpcserver_booter_aggregator in _runtime_swig:
_runtime_swig.rpcserver_booter_aggregator_swigregister(rpcserver_booter_aggregator)

PYPORT_STRING = _runtime_swig.PYPORT_STRING

PYPORT_FLOAT = _runtime_swig.PYPORT_FLOAT

class rpcmanager(object):
    r"""Proxy of C++ rpcmanager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(rpcmanager self) -> rpcmanager"""
        _runtime_swig.rpcmanager_swiginit(self, _runtime_swig.new_rpcmanager())
    __swig_destroy__ = _runtime_swig.delete_rpcmanager

    @staticmethod
    def get() -> "rpcserver_booter_base *":
        r"""get() -> rpcserver_booter_base"""
        return _runtime_swig.rpcmanager_get()

    @staticmethod
    def register_booter(booter: "rpcserver_booter_base") -> "void":
        r"""register_booter(rpcserver_booter_base booter)"""
        return _runtime_swig.rpcmanager_register_booter(booter)

# Register rpcmanager in _runtime_swig:
_runtime_swig.rpcmanager_swigregister(rpcmanager)

def rpcmanager_get() -> "rpcserver_booter_base *":
    r"""rpcmanager_get() -> rpcserver_booter_base"""
    return _runtime_swig.rpcmanager_get()

def rpcmanager_register_booter(booter: "rpcserver_booter_base") -> "void":
    r"""rpcmanager_register_booter(rpcserver_booter_base booter)"""
    return _runtime_swig.rpcmanager_register_booter(booter)

class RPC_get_string(object):
    r"""Proxy of C++ pycallback_object< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "std::string", max: "std::string", deflt: "std::string", dtype: "DisplayType"):
        r"""__init__(RPC_get_string self, std::string name, std::string functionbase, std::string units, std::string desc, std::string min, std::string max, std::string deflt, DisplayType dtype) -> RPC_get_string"""
        _runtime_swig.RPC_get_string_swiginit(self, _runtime_swig.new_RPC_get_string(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_string self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_string_add_rpc_variable(self, s)

    def get(self) -> "std::string":
        r"""get(RPC_get_string self) -> std::string"""
        return _runtime_swig.RPC_get_string_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_string self, PyObject * cb)"""
        return _runtime_swig.RPC_get_string_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_string self)"""
        return _runtime_swig.RPC_get_string_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_string self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_string_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_string

# Register RPC_get_string in _runtime_swig:
_runtime_swig.RPC_get_string_swigregister(RPC_get_string)

class RPC_get_int(object):
    r"""Proxy of C++ pycallback_object< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "int", max: "int", deflt: "int", dtype: "DisplayType"):
        r"""__init__(RPC_get_int self, std::string name, std::string functionbase, std::string units, std::string desc, int min, int max, int deflt, DisplayType dtype) -> RPC_get_int"""
        _runtime_swig.RPC_get_int_swiginit(self, _runtime_swig.new_RPC_get_int(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_int self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_int_add_rpc_variable(self, s)

    def get(self) -> "int":
        r"""get(RPC_get_int self) -> int"""
        return _runtime_swig.RPC_get_int_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_int self, PyObject * cb)"""
        return _runtime_swig.RPC_get_int_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_int self)"""
        return _runtime_swig.RPC_get_int_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_int self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_int_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_int

# Register RPC_get_int in _runtime_swig:
_runtime_swig.RPC_get_int_swigregister(RPC_get_int)

class RPC_get_float(object):
    r"""Proxy of C++ pycallback_object< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "float", max: "float", deflt: "float", dtype: "DisplayType"):
        r"""__init__(RPC_get_float self, std::string name, std::string functionbase, std::string units, std::string desc, float min, float max, float deflt, DisplayType dtype) -> RPC_get_float"""
        _runtime_swig.RPC_get_float_swiginit(self, _runtime_swig.new_RPC_get_float(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_float self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_float_add_rpc_variable(self, s)

    def get(self) -> "float":
        r"""get(RPC_get_float self) -> float"""
        return _runtime_swig.RPC_get_float_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_float self, PyObject * cb)"""
        return _runtime_swig.RPC_get_float_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_float self)"""
        return _runtime_swig.RPC_get_float_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_float self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_float_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_float

# Register RPC_get_float in _runtime_swig:
_runtime_swig.RPC_get_float_swigregister(RPC_get_float)

class RPC_get_double(object):
    r"""Proxy of C++ pycallback_object< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "double", max: "double", deflt: "double", dtype: "DisplayType"):
        r"""__init__(RPC_get_double self, std::string name, std::string functionbase, std::string units, std::string desc, double min, double max, double deflt, DisplayType dtype) -> RPC_get_double"""
        _runtime_swig.RPC_get_double_swiginit(self, _runtime_swig.new_RPC_get_double(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_double self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_double_add_rpc_variable(self, s)

    def get(self) -> "double":
        r"""get(RPC_get_double self) -> double"""
        return _runtime_swig.RPC_get_double_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_double self, PyObject * cb)"""
        return _runtime_swig.RPC_get_double_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_double self)"""
        return _runtime_swig.RPC_get_double_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_double self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_double_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_double

# Register RPC_get_double in _runtime_swig:
_runtime_swig.RPC_get_double_swigregister(RPC_get_double)

class RPC_get_complex(object):
    r"""Proxy of C++ pycallback_object< gr_complex > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "std::complex< float >", max: "std::complex< float >", deflt: "std::complex< float >", dtype: "DisplayType"):
        r"""__init__(RPC_get_complex self, std::string name, std::string functionbase, std::string units, std::string desc, std::complex< float > min, std::complex< float > max, std::complex< float > deflt, DisplayType dtype) -> RPC_get_complex"""
        _runtime_swig.RPC_get_complex_swiginit(self, _runtime_swig.new_RPC_get_complex(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_complex self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_complex_add_rpc_variable(self, s)

    def get(self) -> "std::complex< float >":
        r"""get(RPC_get_complex self) -> std::complex< float >"""
        return _runtime_swig.RPC_get_complex_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_complex self, PyObject * cb)"""
        return _runtime_swig.RPC_get_complex_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_complex self)"""
        return _runtime_swig.RPC_get_complex_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_complex self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_complex_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_complex

# Register RPC_get_complex in _runtime_swig:
_runtime_swig.RPC_get_complex_swigregister(RPC_get_complex)

class RPC_get_complexd(object):
    r"""Proxy of C++ pycallback_object< gr_complexd > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "std::complex< double >", max: "std::complex< double >", deflt: "std::complex< double >", dtype: "DisplayType"):
        r"""__init__(RPC_get_complexd self, std::string name, std::string functionbase, std::string units, std::string desc, std::complex< double > min, std::complex< double > max, std::complex< double > deflt, DisplayType dtype) -> RPC_get_complexd"""
        _runtime_swig.RPC_get_complexd_swiginit(self, _runtime_swig.new_RPC_get_complexd(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_complexd self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_complexd_add_rpc_variable(self, s)

    def get(self) -> "std::complex< double >":
        r"""get(RPC_get_complexd self) -> std::complex< double >"""
        return _runtime_swig.RPC_get_complexd_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_complexd self, PyObject * cb)"""
        return _runtime_swig.RPC_get_complexd_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_complexd self)"""
        return _runtime_swig.RPC_get_complexd_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_complexd self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_complexd_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_complexd

# Register RPC_get_complexd in _runtime_swig:
_runtime_swig.RPC_get_complexd_swigregister(RPC_get_complexd)

class RPC_get_vector_float(object):
    r"""Proxy of C++ pycallback_object< std::vector< float > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "std::vector< float,std::allocator< float > >", max: "std::vector< float,std::allocator< float > >", deflt: "std::vector< float,std::allocator< float > >", dtype: "DisplayType"):
        r"""__init__(RPC_get_vector_float self, std::string name, std::string functionbase, std::string units, std::string desc, std::vector< float,std::allocator< float > > min, std::vector< float,std::allocator< float > > max, std::vector< float,std::allocator< float > > deflt, DisplayType dtype) -> RPC_get_vector_float"""
        _runtime_swig.RPC_get_vector_float_swiginit(self, _runtime_swig.new_RPC_get_vector_float(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_vector_float self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_vector_float_add_rpc_variable(self, s)

    def get(self) -> "std::vector< float,std::allocator< float > >":
        r"""get(RPC_get_vector_float self) -> std::vector< float,std::allocator< float > >"""
        return _runtime_swig.RPC_get_vector_float_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_vector_float self, PyObject * cb)"""
        return _runtime_swig.RPC_get_vector_float_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_vector_float self)"""
        return _runtime_swig.RPC_get_vector_float_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_vector_float self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_vector_float_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_vector_float

# Register RPC_get_vector_float in _runtime_swig:
_runtime_swig.RPC_get_vector_float_swigregister(RPC_get_vector_float)

class RPC_get_vector_gr_complex(object):
    r"""Proxy of C++ pycallback_object< std::vector< gr_complex > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", functionbase: "std::string", units: "std::string", desc: "std::string", min: "std::vector< std::complex< float >,std::allocator< std::complex< float > > >", max: "std::vector< std::complex< float >,std::allocator< std::complex< float > > >", deflt: "std::vector< std::complex< float >,std::allocator< std::complex< float > > >", dtype: "DisplayType"):
        r"""__init__(RPC_get_vector_gr_complex self, std::string name, std::string functionbase, std::string units, std::string desc, std::vector< std::complex< float >,std::allocator< std::complex< float > > > min, std::vector< std::complex< float >,std::allocator< std::complex< float > > > max, std::vector< std::complex< float >,std::allocator< std::complex< float > > > deflt, DisplayType dtype) -> RPC_get_vector_gr_complex"""
        _runtime_swig.RPC_get_vector_gr_complex_swiginit(self, _runtime_swig.new_RPC_get_vector_gr_complex(name, functionbase, units, desc, min, max, deflt, dtype))

    def add_rpc_variable(self, s: "rpcbasic_sptr") -> "void":
        r"""add_rpc_variable(RPC_get_vector_gr_complex self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_vector_gr_complex_add_rpc_variable(self, s)

    def get(self) -> "std::vector< std::complex< float >,std::allocator< std::complex< float > > >":
        r"""get(RPC_get_vector_gr_complex self) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > >"""
        return _runtime_swig.RPC_get_vector_gr_complex_get(self)

    def set_callback(self, cb: "PyObject *") -> "void":
        r"""set_callback(RPC_get_vector_gr_complex self, PyObject * cb)"""
        return _runtime_swig.RPC_get_vector_gr_complex_set_callback(self, cb)

    def setup_rpc(self) -> "void":
        r"""setup_rpc(RPC_get_vector_gr_complex self)"""
        return _runtime_swig.RPC_get_vector_gr_complex_setup_rpc(self)

    def activate(self, pyfunc: "PyObject *") -> "void":
        r"""activate(RPC_get_vector_gr_complex self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_vector_gr_complex_activate(self, pyfunc)
    __swig_destroy__ = _runtime_swig.delete_RPC_get_vector_gr_complex

# Register RPC_get_vector_gr_complex in _runtime_swig:
_runtime_swig.RPC_get_vector_gr_complex_swigregister(RPC_get_vector_gr_complex)

GR_M_LOG2E = _runtime_swig.GR_M_LOG2E

GR_M_PI = _runtime_swig.GR_M_PI

GR_M_PI_4 = _runtime_swig.GR_M_PI_4

GR_M_TWOPI = _runtime_swig.GR_M_TWOPI

GR_M_SQRT2 = _runtime_swig.GR_M_SQRT2


def is_power_of_2(x: "long") -> "bool":
    r"""is_power_of_2(long x) -> bool"""
    return _runtime_swig.is_power_of_2(x)

def fast_atan2f(*args) -> "float":
    r"""
    fast_atan2f(float y, float x) -> float
    fast_atan2f(gr_complex z) -> float
    Fast arc tangent using table lookup and linear interpolation.

    This function calculates the angle of the vector (x,y) based on a table lookup and linear interpolation. The table uses a 256 point table covering -45 to +45 degrees and uses symmetry to determine the final angle value in the range of -180 to 180 degrees. Note that this function uses the small angle approximation for values close to zero. This routine calculates the arc tangent with an average error of +/- 0.045 degrees.
    """
    return _runtime_swig.fast_atan2f(*args)

def branchless_clip(x: "float", clip: "float") -> "float":
    r"""branchless_clip(float x, float clip) -> float"""
    return _runtime_swig.branchless_clip(x, clip)

def clip(x: "float", clip: "float") -> "float":
    r"""clip(float x, float clip) -> float"""
    return _runtime_swig.clip(x, clip)

def binary_slicer(x: "float") -> "unsigned int":
    r"""binary_slicer(float x) -> unsigned int"""
    return _runtime_swig.binary_slicer(x)

def quad_45deg_slicer(*args) -> "unsigned int":
    r"""
    quad_45deg_slicer(float r, float i) -> unsigned int
    quad_45deg_slicer(gr_complex x) -> unsigned int
    """
    return _runtime_swig.quad_45deg_slicer(*args)

def quad_0deg_slicer(*args) -> "unsigned int":
    r"""
    quad_0deg_slicer(float r, float i) -> unsigned int
    quad_0deg_slicer(gr_complex x) -> unsigned int
    """
    return _runtime_swig.quad_0deg_slicer(*args)

def branchless_binary_slicer(x: "float") -> "unsigned int":
    r"""branchless_binary_slicer(float x) -> unsigned int"""
    return _runtime_swig.branchless_binary_slicer(x)

def branchless_quad_0deg_slicer(*args) -> "unsigned int":
    r"""
    branchless_quad_0deg_slicer(float r, float i) -> unsigned int
    branchless_quad_0deg_slicer(gr_complex x) -> unsigned int
    """
    return _runtime_swig.branchless_quad_0deg_slicer(*args)

def branchless_quad_45deg_slicer(*args) -> "unsigned int":
    r"""
    branchless_quad_45deg_slicer(float r, float i) -> unsigned int
    branchless_quad_45deg_slicer(gr_complex x) -> unsigned int
    """
    return _runtime_swig.branchless_quad_45deg_slicer(*args)

def p2_round_down(x: "size_t", pow2: "size_t") -> "size_t":
    r"""p2_round_down(size_t x, size_t pow2) -> size_t"""
    return _runtime_swig.p2_round_down(x, pow2)

def p2_round_up(x: "size_t", pow2: "size_t") -> "size_t":
    r"""p2_round_up(size_t x, size_t pow2) -> size_t"""
    return _runtime_swig.p2_round_up(x, pow2)

def p2_modulo(x: "size_t", pow2: "size_t") -> "size_t":
    r"""p2_modulo(size_t x, size_t pow2) -> size_t"""
    return _runtime_swig.p2_modulo(x, pow2)

def p2_modulo_neg(x: "size_t", pow2: "size_t") -> "size_t":
    r"""p2_modulo_neg(size_t x, size_t pow2) -> size_t"""
    return _runtime_swig.p2_modulo_neg(x, pow2)
class random(object):
    r"""pseudo random number generator"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, seed: "unsigned int"=0, min_integer: "int"=0, max_integer: "int"=2):
        r"""__init__(random self, unsigned int seed=0, int min_integer=0, int max_integer=2) -> random"""
        _runtime_swig.random_swiginit(self, _runtime_swig.new_random(seed, min_integer, max_integer))
    __swig_destroy__ = _runtime_swig.delete_random

    def reseed(self, seed: "unsigned int") -> "void":
        r"""
        reseed(random self, unsigned int seed)
        Change the seed for the initialized number generator. seed = 0 initializes the random number generator with the system time. Note that a fast initialization of various instances can result in the same seed.
        """
        return _runtime_swig.random_reseed(self, seed)

    def set_integer_limits(self, minimum: "int const", maximum: "int const") -> "void":
        r"""
        set_integer_limits(random self, int const minimum, int const maximum)
        set minimum and maximum for integer random number generator. Limits are [minimum, maximum) Default: [0, std::numeric_limits< IntType >::max)]
        """
        return _runtime_swig.random_set_integer_limits(self, minimum, maximum)

    def ran_int(self) -> "int":
        r"""
        ran_int(random self) -> int
        Uniform random integers in the range set by 'set_integer_limits' [min, max).
        """
        return _runtime_swig.random_ran_int(self)

    def ran1(self) -> "float":
        r"""
        ran1(random self) -> float
        Uniform random numbers in the range [0.0, 1.0)
        """
        return _runtime_swig.random_ran1(self)

    def gasdev(self) -> "float":
        r"""
        gasdev(random self) -> float
        Normally distributed random numbers (Gaussian distribution with zero mean and variance 1)
        """
        return _runtime_swig.random_gasdev(self)

    def laplacian(self) -> "float":
        r"""
        laplacian(random self) -> float
        Laplacian distributed random numbers with zero mean and variance 1.
        """
        return _runtime_swig.random_laplacian(self)

    def rayleigh(self) -> "float":
        r"""
        rayleigh(random self) -> float
        Rayleigh distributed random numbers (zero mean and variance 1 for the underlying Gaussian distributions)
        """
        return _runtime_swig.random_rayleigh(self)

    def impulse(self, factor: "float") -> "float":
        r"""
        impulse(random self, float factor) -> float
        Exponentially distributed random numbers with values less than or equal to factor replaced with zero. The underlying exponential distribution has mean sqrt(2) and variance 2.
        """
        return _runtime_swig.random_impulse(self, factor)

    def rayleigh_complex(self) -> "gr_complex":
        r"""
        rayleigh_complex(random self) -> gr_complex
        Normally distributed random numbers with zero mean and variance 1 on real and imaginary part. This results in a Rayleigh distribution for the amplitude and an uniform distribution for the phase.
        """
        return _runtime_swig.random_rayleigh_complex(self)

# Register random in _runtime_swig:
_runtime_swig.random_swigregister(random)



